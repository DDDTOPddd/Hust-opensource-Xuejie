# 体系结构的基础知识
## 体系结构基本概念
### 计算机系统中的层次概念
1. 计算机系统 = 软件 + 硬件/固件
2. 计算机语言由低级向高级发展：高一级语言的语句相对于低级语言功能更强，更便于应用，但又都以低级语言为基础
3. 从计算机语言的角度，把计算机系统按系统功能划分成多层次结构

| 层次 | 对应 | 划分 |
|:----|:-----|:------|
|6|应用语言虚拟机|软件|
|5|高级语言虚拟机|软件|
|4|汇编语言虚拟机|软件|
|3|操作系统虚拟机|软件|
|2|机器语言（传统机器级）|硬件或固件|
|1|微程序机器级|硬件或固件|

### 计算机体系结构定义
1. 计算机体系结构定义：程序员所看到的计算机属性，即概念性结构与功能特性
2. 按照计算机系统的多级层次结构，不同级程序员所看到的计算机具有不同属性
3. 透明性：在计算机技术中，对这种本来是存在的事物或属性，但从某种角度看又好像不存在
4. Amdahl提出的体系结构：传统机器级体系结构————即一般所说的机器语言，程序员所看到的传统机器级所具有的属性
5. 对通用寄存器型机器，属性主要指
   1. 数据表示（硬件能直接辨认和处理的数据类型）
   2. 寻址规则（最小寻址单元、寻址方式及其表示）
   3. 寄存器定义（各种寄存器的定义、数量和使用方式）
   4. 指令集（机器指令的操作类型和格式、指令间的排序和控制机构等）
   5. 中断系统（中断类型和中断响应硬件的功能等）
   6. 机器工作状态的定义切换（管态和目态等）
   7. 存储系统（主存容量、程序员可用的最大存储容量等）
   8. 信息保护（信息保护方式和硬件对信息保护的支持）
   9. I/O结构（I/O连接方式、处理机/存储器与I/O设备间数据传送的方式和格式以及I/O操作的状态等）
> 经典计算机体系结构概念的实质
>   计算机系统中软硬件界面的确定，界面之上是软件功能，界面之下是硬件和固件功能

### 计算机组成和计算机实现技术
1. 计算机组成：计算机体系结构的逻辑实现
2. 计算机实现：计算机组成的物理实现

**一种体系结构可以有多种组成**  
**一种组成可以有多种物理实现**

3. 系列机/兼容机/软件兼容
   1. 系列机：在一个厂家内生产的具有相同体系结构，但具有不同组成和实现的一系列不同型号的机器

### 计算机的分代和分类
+ 桌面计算机
+ 服务器
+ 物联网/嵌入式计算机
+ 个人移动装置
+ 集群/数据中心计算系统

+ Flynn分类法：按照指令流和数据流的多倍性特征对计算机系统进行分类
  + 指令流：机器执行的指令序列
  + 数据流：由指令调用的数据序列，包括输入数据和中间结果
  + 多倍性(multiplicity)：在系统性能瓶颈不见上同时处于同一执行阶段的指令或数据的最大可能个数
  1. 单指令流单数据流SISD -- Single Instruction Stream Single Data Stream
  2. 单指令流多数据流SIMD -- Single Instruction Stream Multiple Data Stream
  3. 多指令流单数据流MISD -- Multiple Instruction Stream Single Data Stream
  4. 多指令流多数据流MIMD -- Multiple Instruction Stream Multiple Data Stream

+ SISD：传统顺序处理机
  + 包括单指令功能部件处理机，多功能部件处理机，流水线处理机————标量流水线处理机
+ SIMD：
  + 包括并行处理机，阵列处理机，向量处理机，超标量处理机，超流水线处理机，即多个PU按一定的方式互联，在同一个CU控制下，并行的对多个数据进行处理
+ MIMD：
  + 多处理机系统
+ MISD：实际不存在

## 定量分析技术基础
### 性能设计和评测的基本原则
#### 三条基本原则和方法
1. 大概率事件优先原则
     + 对于大概率时间（最常见的事件），赋予它优先的处理权和资源使用权，以获得全局的最优结果
2. Amdahl定律
     + 加快某部件执行速度所获得的系统性能和加速比，受限于该部件在系统中所占的重要性
3. 程序局部性原理
     + 程序在执行时所访问地址的分布不是随机的，而是相对地簇聚；这种 簇聚包括指令和数据两部分
       + 程序的时间局部性：程序即将用到的信息很可能就是目前正在使用的信息
       + 程序的空间局部性：程序即将用到的信息很可能与目前正在使用的信息在空间上相邻或者临近

#### Amdahl定律
系统中某一部件由于采用某种更快的执行方式后整个系统性能的提高与这种执行方式的使用频率或占总执行时间的比例有关
##### 加速比
$$ 系统加速比 = \frac{系统性能_{改进后}}{系统性能_{改进前}} = \frac{总执行时间_{改进前}}{总执行时间_{改进后}} $$
+ 系统加速比依赖于两个因素
  + 可改进比例：可改进部分在原系统计算时间中所占的比例，它总是小于等于1
  + 部件加速比：可改进部分改进以后的性能提高，一般情况下它是大于1的
$$ 总执行时间_{改进后} = 不可改进部分的执行时间 + 可改进部分改进后的执行时间 $$
$$ 总执行时间_{改进后} = (1 - 可改进比例) \times 总执行时间_{改进前} + \frac{可改进比例 \times 总执行时间_{改进前}}{部件加速比} $$
$$ \qquad = [(1 - 可改进比例) + \frac{可改进比例}{部件加速比}] \times 总执行时间_{改进前} $$
$$ 系统加速比 = \frac{总执行时间_{改进前}}{总执行时间_{改进后}} = \frac{1}{(1-可改进比例) + \frac{可改进比例}{部件加速比}} $$

$Fe = \frac{可改进部分占用的时间}{改进前整个任务的执行时间}$，它总小于1  

$Se = \frac{改进前改进部分的执行时间}{改进后改进部分的执行时间}$，它总大于1

改进后整个任务的执行时间为:
$$ T_n = T_0 \cdot (1 - Fe + \frac{Fe}{Se}) $$
其中$T_0$为改进前的整个任务的执行时间

改进后整个系统的加速比为:
$$ S_n = \frac{T_0}{T_n} = \frac{1}{(1-Fe) + \frac{Fe}{Se}} $$
其中，$(1-Fe)$表示不可改进部分，当$Se -> \inf$时， $S_n = \frac{1}{1-Fe}$。因此可改进极限受Fe的约束

当存在多个部件的时候
$$ S = \frac{1}{(1 - \sum_i f_i) + \sum_i \frac{f_i}{S_i}} $$

+ 加速比$S_n$和可增强性能部分$F_e$的关系
  + 为使系统能获得较高性能加速比，则可曾倩部分必须占有较大的比例；否则，增强该功能就没有多大意义

##### 性能递减规则
如果仅仅对计算机中的一部分做性能改进，则改进越多，系统获得的改进效果越来越不明显

推论：如果只针对整个任务的一部分进行优化，那么所获得的加速比不大于$\frac{1}{1-F_e}$

#### CPU的性能
1. 将程序执行的时间进行分解
   1. 计算机工作的时钟频率：计算机系统中于实现技术和工艺有关的因素。单位是MHz(f)
   2. 总时钟周期数：程序执行的cpu时间————CPU时间=总时钟周期数 / 时钟频率
2. 指令时钟数CPI(Cycles Per Instruction)
     + 一个与计算机体系结构有关的参数
     + $CPI = \frac{总时钟周期数}{IC}$ 
     + IC：程序执行过程中所处理的指令数
3. 程序执行的CPU时间可以写成
     + $总CPU时间 = CPI \times IC \div 时钟频率$  
     + $总CPU时间 = CPI \times IC \times CT$
     + CPI：反映了计算机实现技术、计算机指令集结构和计算机组织
     + IC：反映了计算机指令的结构和编译技术
     + 时钟频率/时钟周期时间反映了计算机实现技术、生产工艺和计算机组织
4. 对CPU性能进行进一步细化
     + $CPI_i$：对第i种指令的处理时间
     + $IC_i$：在程序中第i种指令出现的次数
     + 程序执行时间：$CPU时间 = \sum _{i = 1}^{n}(CPI_i \times IC_i) \div 时钟频率$
     + $CPI = \frac{\sum _{i = 1}^nb (CPI_i \times IC_i)}{IC} = \sum_{i=1}^n (CPI_i \times IC_i \div IC)$
     + 其中，$IC_i\div Ic$反映了第i中指令在程序中所占的比例

+ 性能优化
  + 独立的性能优化技术
    + 编译优化
    + 高级电路或架构
  + 非独立的性能优化技术
    + 减少指令数量
    + 降低CPI
    + 减少周期时间

#### 计算机性能的评测
+ 任务执行时间
  + 可被观察、被测量，是评估一个系统性能的核心指标，其快慢是用户最能直观感受到的服务体验
  + 响应时间、服务时间、处理延迟等
+ 任务是相对的
  + 应用程序，I/O请求
+ 通过任务执行时间相对快慢来评价系统的性能高低
+ 任务吞吐率
  + 单位时间内完成的任务总数
  + 网络：每秒位数(bps)；存储设备：MB/s或IOPS；数据库：每秒查询数(QPS)
+ 实际吞吐率依赖于工作负载行为
  + 服务装置通常是被被动接受并处理任务
  + 单位时间内任务发送数量称之为负载强度
  + 不断增加负载强度到一定值之后，服务装置实际吞吐率不会再增加，这个吞吐率称之为峰值吞吐率，也被称为处理容量或带宽
  + 峰值吞吐率或者带宽是系统内在禀性的反映
  + 如果系统只能穿行执行任务，则平均吞吐率就是平均执行实现的倒数
+ 响应时间和吞吐率
  + 相同点：都认为能够以最短时间完成任务的计算机就是最快的
  + 不同点：响应时间针对单任务，吞吐率针对多任务

## 计算机体系结构的发展
### 冯诺依曼结构及其改进
+ 存储程序原理的基本点：指令驱动
  + 程序预先存放再计算机存储器中，机器一旦启动，就能按照程序指定的逻辑顺序执行这些程序，自动完成由程序所描述的处理工作
+ 冯诺依曼结构的主要特点
  + 计算机以运算器为中心
  + 在存储器中，指令和数据同等对待
    + 指令和数据一样可以进行运算，即由指令组成的程序是可以修改的
  + 存储器是按地址访问、按顺序线性编址的一维结构，每个单元的位数是固定的
  + 指令的执行是顺序的
    + 一般是按照指令在存储器中存放的顺序执行
    + 程序的分支由转移指令实现
    + 由指令计数器PC指明当前正在执行的指令在存储器中的地址
  + 指令由操作码和地址吗组成
  + 指令和数据均以二进制编码表示，采用二进制运算
+ 对系统结构进行的改进
  + 输入/输出方式的改进
    + 程序控制
      + 程序等待
      + 程序中断
    + DMA
      + 成组传递
      + 周期挪用
    + I/O处理机
      + 通道
      + 外围处理机
  + 采用并行处理技术
  + 存储器组织结构的发展
    + 相联存储器与相联处理机
    + 通用寄存器组
    + 高速缓冲存储器Cache
  + 指令系统的发展
    + 复杂指令集计算机CISC
    + 精简指令集计算机RISC

## 计算机系统结构中并行性的发展
### 并行性的概念
+ 并行性
  + 计算机系统在同一时刻或者同一时间间隔内进行多种运算或操作。——只要在时间上相互重叠，就存在并行性
+ 同时性：两个或两个以上的事件在同一时刻发生
+ 并发性：两个或两个以上的事件在同一时间间隔内发生
+ 从处理数据的角度来看，并行性等级从低到高可分为
  + 字串位串：每次只对一个字的一位进行处理：最基本的串行处理方式，不存在并行性
  + 字串位并：同时对一个自的全部位进行处理，不同字之间是串行的 —— 开始出现并行性
  + 字并位串：同时对许多字的同一位（称为位片）进行处理 —— 具有较高的并行性
  + 全并行：同时对许多字的全部位或部分位进行处理 —— 最高一级的并行
+ 从执行程序的角度来看，并行性等级从低到高可分为
  + 指令内部并行：单挑指令中各微操作之间的并行
  + 指令级并行：并行执行两条或以上的指令
  + 线程级并行：并行执行两个或以上的线程 —— 通常是一个进程内派生的多个线程为调度单位
  + 任务级或过程级并行：并行执行两个或以上的过程或任务（程序段）—— 以子程序或进程为调度单元
  + 作业或程序级并行：并行执行两个或以上的作业或程序

### 提高并行性的技术途径
+ 时间重叠
  + 引入时间因素，让多个处理过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分，以加快硬件周转而赢得速度
+ 资源重复
  + 引入空间因素，以数量取胜。通过重复设置硬件资源，大幅度地提高计算机系统的性能
+ 资源共享
  + 一种软件方法，使多个任务按照一定时间顺序轮流使用同一套硬件设备

### 单片系统中并行性的发展
+ 在发展高性能单处理机过程中，起主导作用的是时间重叠原理
  + 实现时间重叠的基础：部件功能专用化
    + 把一件工作按功能分割为若干相互联系的部分
    + 把每一部分指定给专门的部件完成
    + 然后按时间重叠原理把各部分的执行过程在时间上重叠起来，使所有部件依次分工完成一组同样的工作
+ 在单处理机中，资源重复原理的运用也已十分普遍
  + 多体存储器
  + 多操作部件
    + 通用部件被分解为若干个专用部件，如加法、乘法、触发、逻辑运算部件等，而且同一种部件也可以重复设置多个
    + 如果指令所需的操作部件空闲，就可以开始执行这条指令（操作数已经准备好）。实现了指令级并行
  + 阵列处理机（并行处理器）
    + 设置许多相同的处理单元，让它们在同一个控制器的指挥下，按照同一条指令的要求，对向量或数组的各元素同时进行同一操作，就形成了阵列处理机
    + 在单处理机中，资源共享的概念实质上是用单处理机模拟多处理机的功能，形成所谓虚拟机的概念
    + 分时系统

### 多机系统中并行性的发展
+ 多机系统遵循时间重叠、资源重复、资源共享原理，发展为3中不同的多处理机
  + 同构型多处理机、异构型多处理机、分布式系统
+ 耦合度
  + 反映多机系统中各机器之间物理连接的紧密程度和交互作用能力的强弱
  + 紧密耦合系统（直接耦合系统）：在这种系统中，计算机之间的物理连接的频带较高，一般是铜鼓哦总线或告诉开关互联，可以共享主存
  + 松散耦合系统（简介耦合系统）：一般是铜鼓哦通道或通信线路实现计算机之间的互联，可以共享外存设备（磁盘、磁带等）。机器之间的相互作用是在文件或数据集一级上进行
    + 表现为两种形式
    + 多台计算机和共享的外存设备连接，不同机器之间实现功能上的分工（功能专用化），机器处理的结果以文件或数据集的形式发送到共享外存设备，供其它机器继续处理
    + 计算机网，通过通信线路连接，实现更大范围的资源共享
+ 功能专用化（实现时间重叠）
  + 专用外围处理机：e.g. 输入/输出功能的分离
  + 专用处理机：e.g. 数组运算、高级语言翻译、数据库管理等，分离出来
  + 异构型多处理机系统
    + 由于多个不同类型、至少担负不同功能的处理机组成，它们按照作业要求的顺序，利用时间重叠原理，一次对它们的多个任务进行加工，各自完成规定的功能动作
+ 机间互联
  + 容错系统
  + 可重构系统
  + 同构型多处理机系统

# 流水线技术
## 基本概念
+ 流水线技术
  + 把一个重复的过程分解为若干个子过程，每个子过程由专门的功能部件来实现
  + 把多个处理过程在时间上错开，一次通过各功能段，这样，每个子过程就可以与其它的子过程并行进行
+ 流水线中的每个子过程及其功能部件称为流水线的级或段，段与段相互连接形成流水线。流水线的段数称为流水线的深度
+ 浮点加法流水线示例
  + 把流水线技术应用于运算的执行过程，就形成了运算操作流水线，也称为部件级流水线
  + 把浮点加法的全过程分解为求阶差、对阶、尾数相加、规格化四个子过程
  + 理想情况，提高3倍速度
+ 时-空图
  + 时-空图从时间和空间两个方面描述了流水线的工作过程。
  + 时-空图中，横坐标代表时间，纵坐标代表各流水线的各个段
+ 流水技术的特点
  + 流水线把一个处理过程分解为若干个子过程（段），每个子过程由一个专门的功能部件来实现
  + 流水线中各段的时间应尽可能相等，否则将引起流水线堵塞、断流
    + 时间最长的段将称为流水线的瓶颈
  + 流水线每一个段的后面都要由一个缓冲寄存器（锁存器），称为流水寄存器
    + 作用：在相邻的两段之间传送数据，以供后面要用到的信息，并把各段的处理工作相互隔离
  + 流水技术适合于大量重复的时序过程，只有在输入端不断地提供任务，才能充分发挥流水线的效率
  + 流水线需要由通过时间和排空时间
    + 通过时间：第一个任务从进入流水线到流出结果所需的时间
    + 排空时间：最后一个任务从进入流水线到流出结果所需的时间

### 流水线的分类
+ 部件级、处理机级及处理机间流水线（按照流水技术用与计算机系统的等级不同）
  + 部件级流水线（运算操作流水线）：把处理机中的部件分段，再把这些分段相互连接起来，使得各种类型的运算操作都能够按照流水方式进行
  + 处理机级流水线（指令流水线）：把指令的执行过程按照流水方式处理。把每一条指令的执行过程分解为若干个子过程，每个子过程在独立的功能部件中执行
  + 系统级流水线（宏流水线）：把多台处理机串行连接起来，对同一数据流进行处理，每个处理机完成整个任务中的一部分
+ 单功能流水线与多功能流水线
  + 单功能流水线：只能完成一种固定功能的流水线
  + 多功能流水线：流水线的各段可以进行不同的连接，以实现不同的功能
+ 静态流水线与动态流水线（按照同一时间内各段之间的连接方式对多功能流水线作进一步的分类）
  + 静态流水线：在同一时间内，多功能流水线中的各段只能按同一种功能的连接方式工作
    + 对于静态流水线来说，只有当输入的是统一穿相同的运算任务时候流水线的效率才能得到充分的发挥
  + 动态流水线：在同一时间内，多功能流水线中的各段可以按照不同的方式hi链接，同时执行多种功能
    + 优点：灵活，能够提高流水线各段的使用率，从而提高处理速度
    + 缺点：控制复杂
+ 线性流水线与非线性流水线（按照流水线中是否由反馈回路来进行分类）
  + 线性流水线：流水线的各段串行连接，没有反馈回路。数据通过流水线中的各段时，每一个段最多只流过一次
  + 非线性流水线：流水线中除了有串行的连接外，还有反馈回路
  + 非线性流水线的调度问题：确定什么时候向流水线引进新的任务，才能使该任务不会与先前进入流水线的任务发生冲突——争用流水段
+ 顺序流水线与乱序流水线（根据任务流入和流出的顺序是否相同来进行分类）
  + 顺序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序完全相同。每一个任务在流水线的各段中是一个跟着一个顺序流动的
  + 乱序流水线：流水线输出端任务流出的顺序与输入端任务流入的顺序可以不同，允许后进入流水线的任务先完成（从输出端流出）

## 流水线的性能指标
### 吞吐率
吞吐率： 在单位时间内流水线所完成的任务数量或输出结果的数量
$$ TP = \frac{n}{T_k} $$
##### 各段时间均相等的流水线
+ 流水线完成n个连续任务所需要的总时间为(假设一条k段线性流水线)$T_k = k \Delta t + (n-1) \Delta t = (n + k - 1) \Delta t$
+ 流水线的实际吞吐率$TP = \frac{n}{(n + k - 1) \Delta t}$
+ 最大吞吐率$TP_{max} = lim_{n -> \infty} \frac{n}{(n + k - 1) \Delta t} = \frac{1}{\Delta t}$
+ 最大吞吐率与实际吞吐率的关系$TP = \frac{n}{n + k - 1}TP_{max}$
+ 流水线的实际吞吐率小于最大吞吐率，它除了与每个段的时间有关外，还与流水线的段数k以及输入到流水线中的任务n有关
+ 只有当$n >> k$时，才有$TP \approx TP_{max}$

##### 各段时间不完全相等的流水线
实际吞吐率$TP = \frac{n}{\sum_{i=1}^k \Delta t_i + (n - 1) max(\Delta t_1, \Delta t_2, ..., \Delta t_k)}$

流水线的最大吞吐率为$TP_{max} = \frac{1}{max(\Delta t_1, \Delta t_2, ..., \Delta t_k)}$

#### 解决流水线瓶颈问题的常用方法
+ 细分瓶颈段
+ 重复设置瓶颈段
  + 缺点：控制逻辑比较复杂，所需的硬件增加了

### 流水线的加速比
加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比

假设：不使用流水线（顺序执行）所用的时间为$T_s$，使用流水线后所用的时间为$T_k$，则该流水线的加速比$S=\frac{T_s}{T_k}$

##### 各段时间相等的流水线
一条k段流水线完成n个连续任务，所需时间为$T_k = (k + n - 1) \Delta t$

顺序执行n个任务，所需时间为$T_s = nk\Delta t$

流水线的实际加速比为$S = \frac{nk}{k + n - 1}$

最大加速比$S_{max} = lim_{n -> \inf} \frac{nk}{n + k - 1} = k$

##### 各段时间不完全相等的流水线
一条k段流水线完成n个连续任务的实际加速比为
$$ S = \frac{n \sum _{i=1}^k \Delta t_i}{\sum_{i=1}^k \Delta t_i + (n - 1) max (\Delta t1, ... \Delta t_k)} $$

### 流水线的效率
流水线的效率：流水线中的设备实际使用时间与整个运行时间的比值，即流水线设备的利用率

由于流水线有通过时间和排空时间，所以在连续完成n个任务的时间内，各段并不是满负荷的工作

从时空图的角度来看，效率就是n个任务占用的时空面积/k个段的总时空面积(最大矩形的面积)

##### 各段时间相等
各段的效率$e_i$相同，$e_i=\frac{n\Delta t}{T_k} = \frac{n}{k + n - 1}$

整条流水线的效率为$E = \frac{e_1 + e_2 + ... + e_k}{k} = \frac{ke_1}{k} = \frac{k n \Delta t}{kT_k} = \frac{n}{k + n - 1}$

最高效率为$E_{max} = lim_{n -> \inf} \frac{n}{k + n - 1} = 1$

当流水线各段时间相等时候，流水线的效率与吞吐率成正比$E = TP \cdot \Delta t$

流水线的效率是它的实际加速比S与它的最大加速比k的比值$E=\frac{S}{k}$

##### 各段时间不相等
$$ E = \frac{n \cdot \sum _{i=1}^k \Delta t_i}{k[\sum_{i=1}^k\Delta t_i + (n-1)\cdot max(\Delta t_1, ..., \delta t_k)]} $$

### 流水线设计中的若干问题
+ 瓶颈问题
  + 理想情况下，流水线在工作时，其中的任务是同步地每一个时钟周期往前流动一段
  + 当流水线各段不均匀时，机器的时钟周期取决于瓶颈段的延迟时间
  + 在设计流水线时，要尽可能使各段时间相等
+ 流水线的额外开销
  + 流水寄存器延迟：建立时间，传输延迟
  + 时钟偏移开销：时钟到达各流水寄存器的最大差值时间
+ 明确意义
  + 流水线不能减少（而且一般是增加）单条指令的执行时间，但却能提高吞吐率
  + 适当增加流水线的深度（段数）可以提高流水线的性能
  + 流水线的深度受限于流水线的额外开销
  + 当时钟周期小到与额外开销相同时，流水已经没有意义。因为这时在每一个时钟周期中已经没有时间来做有用的工作

## 非线性流水线的调度
+ 在非线性流水线中，存在反馈回路，当一个任务在流水线中流过时，可能要多次经过某些段
+ 流水线调度要解决的问题：应按什么样的时间间隔向流水线输入新任务，才能既不发生功能段使用冲突，又能使流水线又较高的吞吐率和效率

### 单功能非线性流水线的最优调度
+ 向一条非线性流水线的输入端连续输入两个任务之间的时间间隔称为非线性流水线的启动距离
+ 会引起非线性流水线功能段使用冲突的启动距离则称为禁用启动距离
+ 启动距离和禁用启动距离一般都是用时钟周期数来表示，是一个正整数
+ 预约表
  + 横向（向右）：时间（一般用时钟周期表示）
  + 纵向（向下）：流水线的段
  + 如果在第n个时钟周期使用了第k段，则在第k行和第n列的交叉处各自里又一个勾
  + 如果在第k行和第n列的交叉处的格子里有一个勾，则表示在第n个时钟周期要使用第k段

#### 预约表
##### 根据预约表写出禁止表F
+ 禁止表F：一个由禁用启动距离构成的集合
+ 具体方法：对于预约表的每一行的任何一对勾，用它们所在的列号相减，列出各种可能的差值，然后删除相同的，剩下的就是禁止表的元素
+ 根据禁止表写出初始冲突向量$C_0$（进行从一个集合到二进制位串的变换）
  + 冲突向量C：一个N位的二进制串
  + 设$C_0=(c_NC_{N-1}...C_2c_1)$，则当$i \in F$，$c_i = 1$，否则$f_i=0$
  + $c_i=0$：允许间隔i个时钟周期后送入后续任务
  + $c_i=1$：不允许间隔i个时钟周期后送入后续任务
+ 根据冲突向量$C_0$画出状态转换图
  + 当第一个任务进入流水线后，初始冲突向量$C_0$决定了下一个任务需要间隔多少个时钟周期才可以进入
  + 在第二个任务流入后
    + 假设第二个任务是在于第一个任务间隔j个时钟周期流入，这时，有序第一个任务已经在流水线中前进了j个时钟周期，其响应的禁止表中各元素的值都应该减去j，并丢弃小于等于0的值
    + 对冲突向量来说，就是逻辑右移j位
    + 在冲突向量上，就是对它们的冲突向量进行或运算
    + $(C_0 >> j) | C_0$
  + 推广到更一般的情况
    + 假设$C_k$：当前的冲突向量；j：允许的时间间隔
    + 则新的冲突向量为$(C_k >> j) | C_0$
  + 对于所有允许的时间间隔都按照上述步骤求出其新的冲突向量，并且把新的冲突向量作为当前冲突向量，反复使用上述步骤，直到不再产生新的冲突向量为止
+ 根据状态转换图写出最优调度方案
  + 根据流水线状态图，由初始状态触发，任何一个闭合回路即为一种调度方案
  + 列出所有可能的调度方案，计算出每种方案的平均时间间隔，从中找出其最小者即为最优调度方案

## 流水线的相关与冲突
### 经典5段流水线
+ IF取指令周期
  + 以程序计数器PC中的内容作为地址，从存储器中取出指令并放入寄存器IR
  + 同时PC值加4，指向顺序的下一条地址
+ ID指令译码/读寄存器周期
  + 对指令进行译码，并用IR中的寄存器地址去访问通用寄存器组，读出所需的操作数
+ EX执行/有效地址计算周期
  + load和store指令：ALU把指令中所指定的寄存器的内容与偏移量相加，形成访存有效地址
  + 寄存器-寄存器ALU指令：ALU按照操作码指定的操作对通用寄存器组中读出的数据进行运算
  + 寄存器-立即数ALU指令：ALU按照操作码指定的操作对从通用寄存器组中读出的操作数和指令中给出的立即数进行运算
  + 分支指令：ALU把指令中给出的偏移量与PC相加，形成转移目标的地址。同时，对在前一个周期读出的操作数进行判断，确定分支是否成功
+ MEM存储器访问/分支完成周期
  + load指令：用上一个周期计算出的有效地址，从存储器中读出相应的数据
  + store指令：把指定的数据写入这个有效地址所指出的存储器单元（**完成**）
  + 分支指令：如果分支成功，把转移目标地址送入PC。（**分支指令也在此阶段全部完成**）
  + 其它指令在该周期无操作
+ WB写回周期
  + ALU运算指令和load指令在这个周期把结果数据写入通用寄存器组

在以上的实现方案中，分支指令和store指令需要4个周期，其它指令需要5个周期
### 相关
+ 相关：两条指令之间存在某种依赖关系。
+ 如果两条指令相关，则它们就有可能不能在流水线中重叠执行或者只能部分重叠执行
+ 三种相关类型
  + 数据相关
  + 名相关
  + 控制相关

#### 数据相关
+ 对于两条指令i和j，如果下述条件之一成立，则称指令j与指令i数据相关
  + 指令j使用指令i产生的结果
  + 指令j与指令k数据相关，而指令k又与指令i数据相关（数据相关具有传递性）

#### 名相关
+ 名：指令所访问的寄存器或存储单元的名称
+ 如果两条指令使用相同的名，但是它们之间并没有数据流动，则称这两条指令存在名相关
+ 指令j与指令i之间的名相关有两种
  + 反相关：如果指令j写的名与指令i读的名相同（指令j写的名=指令i读的名），则成指令i和j发生了反相关
  + 输出相关：如果指令j和指令i写相同的名（指令j写的名=指令i写的名），则称指令i和j发生了输出相关
+ 特点
  + 名相关的两条指令之间并没有数据的传送
  + 如果一条指令中的名改变了，并不影响另外一条指令的执行
  + 换名技术
    + 通过改变指令中操作数的名来消除名相关
    + 对于寄存器操作数进行换名称为寄存器换名
    + 既可以通过编译器静态实现，也可以用硬件动态实现

#### 控制相关
+ 控制相关是指由分支指令引起的相关
  + 为了保证程序应有的执行顺序，必须严格按控制相关确定的执行顺序
+ 典型的程序结构即使if then结构
+ 带来的限制
  + 与一条分支指令控制相关的指令不能被移到该分支之前，否则这些指令就不受该分支控制了（then中的指令不能移到if之前）
  + 如果一条指令与某分支指令不存在控制相关，就不能把该指令移到该分支之后

### 冲突
+ 冲突：对于具体的流水线来说，由于相关的存在，使得指令流中的下一条指令不能在指定的时钟周期执行
+ 类型
  + 结构冲突：因硬件资源满足不了指令重叠执行的要求而发生的冲突
  + 数据冲突：当指令在流水线中重叠执行时，因需要用到前面指令的执行结果而发生的冲突
  + 控制冲突：流水线遇到分支指令和其它会改变PC值的指令所引起的冲突
+ 问题
  + 导致错误的执行结果
  + 流水线可能会出现停顿，从而降低流水线的效率和实际的加速比
  + 当一条指令被暂停时，在该暂停指令之后流出的所有指令都要被暂停，而在该暂停指令之前流出的指令则继续进行

#### 结构冲突
+ 在流水线处理机中，为了能够使各种组合的指令都能顺利的重叠执行，需要对功能部件进行流水或重复设置资源
+ 如果某种指令组合因为资源冲突而不能正常执行，则称该处理机有结构冲突
+ 常见的导致结构冲突的原因
  + 功能部件不是完全流水
  + 资源份数不够
+ e.g. 访存冲突
  + 有些流水线处理机只有一个存储器，将数据和指令放在一起，访存指令会导致访存冲突
  + 解决方法1：设置相互独立的指令存储器和数据存储器，或设置相互独立的指令cache和数据cache
  + 解决方法2：插入暂停周期（流水线气泡）

#### 数据冲突
+ 当相关的指令靠得足够近时，它们在流水线中的重叠执行或者重新排序会改变指令读/写操作数的顺序，使之不同于它们串行执行时的顺序，则发生了数据冲突
+ 类型
  + 写后读冲突（RAW）：在i写入之前，j先去读，j读出的内容就是错误的（对应数据相关）
  + 写后写冲突（WAW）：在i写入之前，j先写，导致最后写入的内容是i的而不是j的（对应输出相关）
    + 写后写冲突只可能发生在这样的流水线中
      + 流水线中不只一个段可以进行写操作
      + 指令被重新排序了
  + 读后写冲突（WAR）：在i读之前，j先写，i读出的内容是错误的（对应反相关）
    + 仅发生在这样的情况下
      + 有些指令的写结果操作提前了，而且有些指令的读操作滞后了
      + 指令被重新排序了
+ 通过定向技术减少数据冲突引起的停顿
  + 思路：在计算结果尚未出来之前，后面等待使用该结果的指令并不真正立即需要改计算结果，如果能够将该计算结果从其产生的地方直接送到其它指令需要它的地方，那么就可以避免停顿
  + 实现
    + EX段和MEM段之间的流水寄存器中保存的ALU运算结果总是回送到ALU的入口
    + **当定向硬件检测到前一个ALU运算结果写入的寄存器就是当前ALU操作的源寄存器时，那么控制逻辑就选择定向的数据作为ALU的输入，而不采用从通用寄存器组读出的数据**
    + 结果数据不仅可以从某一功能部件的输出定向到自身的输入，而且还可以定向到其它功能部件的输入
+ 需要停顿的数据冲突
  + 不是所有的数据冲突都可以用重定向技术来解决
  + 增加流水线互锁机制，插入暂停
  + 作用：检测发现数据冲突，并使流水线停顿，直至冲突消失
+ 依靠编译器解决数据冲突（软件方法）
  + 让编译器重新组织指令顺序来消除冲突，称为指令调度或流水线调度。

#### 控制冲突
+ 执行分支指令的结果有两种
  + 分支成功：PC值改变为分支转移的目标地址在条件判定和转移地址计算都完成后，才改变PC值
  + 分支失败：PC的值保持正常递增，指向顺序的下一条指令
+ 处理分支指令最简单的方法：等结果
  + “冻结”或“排空”流水线
  + 优点：简单
+ 把由分支指令引起的延迟称为分支延迟
+ 分支指令在目标代码中出现的频度影响实际CPI
  + 实际CPI = 理想CPI + 平均每条指令的停顿周期数
+ 可采取措施来减少分支延迟
  + 在流水线中尽早判断出分支转移是否成功
  + 尽早计算出分支目标地址
+ 通过软件（编译器）来减少分支延迟的方法
  + 预测分支失败
    + 允许分支指令后的指令继续在流水线中流动，好像什么都没有发生
    + 若确定分支失败，将分支指令看作是一条普通指令，流水线正常流动
    + 若确定分支成功，流水线就把在分支指令之后去除的所有指令转化为空操作，并按分支目的地重新取指令
    + 要保证：分支结果出来之前不能改变处理机的状态，以便一旦猜错，处理机能够回退到原先的状态
  + 预测分支成功
    + 假设分支转移成功，并从分支目标地址处取指令执行
    + 起作用的前提：先知道分支目标地址，后知道分支是否成功
  + 隐藏分支延迟
    + 从逻辑上“隐藏”分支指令的执行时间，把延迟分支堪称是由原来的分支指令和若干个延迟槽构成，不管分支是否成功，都要按顺序执行延迟槽中的指令
+ 分支延迟指令的调度
  + 任务：在延迟槽中放入有用的指令
  + 由编译器完成，能否带来好处取决于编译器能否把有用的指令调度到延迟槽中
  + 三种调度方法
    + 从前调度
      + 被调度的指令必须于分支无关
      + 任何情况都起作用
    + 从目标处调度
      + 必须保证在分支失败时执行被调度的指令不会导致错误，有可能需要复制指令
      + 分支成功时起作用，但由于复制指令，有可能增大程序空间
    + 从失败处调度
      + 必须保证在分支成功时执行被调度的指令不会导致错误
      + 分支失败时
  + 限制
    + 可以被放入延迟槽中的指令需要满足一定的条件
    + 编译器预测分支转移方向的能力
  + 改进：分支取消机制（取消分支）
  + 当分支的实际实行方向和事先锁预测的一样时，执行分支延迟槽中的指令，否则就将分支延迟槽中的指令转化为一个空操作

# 指令级并行及其开发——硬件方法
## 指令级并行的概念
+ 开发ILP的方法可以分为两大类
  + 基于软件的静态开发方法
  + 基于硬件的动态开发方法
+ 流水线处理机的实际CPI
  + 理想流水线的CPI加上各类停顿的时钟周期数
  + $CPI_{流水线} = CPI_{理想}+停顿_{结构冲突} + 停顿_{数据冲突}+停顿_{控制冲突}$
  + 理想CPI是衡量流水线最高性能的一个指标
  + IPC：每个时钟周期完成的指令条数
+ 基本程序块
  + 一串连续的代码除了入口以外，没有其它的分支指令和转入点
  + 程序平均每4~7条指令就会有一个分支
+ 循环级并行：使一个循环中的不同循环体并行执行
  + 开发循环的不同迭代之间存在的并行性

## 指令的动态调度
+ 静态调度
  + 依靠编译器对代码进行静态调度，以减少相关和冲突
  + 它不是在程序执行的过程中，而是在编译期间进行代码调度和优化
  + 通过把相关指令拉开距离来减少可能产生的停顿
+ 动态调度
  + 在程序的执行过程中，依靠专门硬件对代码调度，减少数据相关导致的停顿

### 动态调度的基本思想
+ 把指令流出的工作拆分为两步
  + 检测结构冲突
  + 等待冲突数据消失
  + 只要检测到没有结构冲突，就可以让指令流出，并且流出后的指令一旦其操作数就绪就可以立即执行
+ 乱序执行
  + 指令的执行顺序与程序顺序不相同
  + 指令的完成也是乱序完成的：指令的完成顺序与程序顺序不相同
+ 为了支持乱序执行，把5段流水线的译码阶段再分成两个阶段
  + 流出(Issue, IS)：指令译码，检查是否存在结构冲突(in order issue)
  + 读操作数(Read Operands, RO)：等待数据冲突消失，然后读操作数
  + 本来的5段流水线中，是不会发生WAR冲突和WAW冲突的，但是乱序执行就有可能发生了。
+ 动态调度的流水线支持多条指令同时处于执行当中
  + 要求：具有多个功能部件、或者功能部件流水化、或者兼而有之

## 动态分支预测技术
+ 所开发的ILP越多，控制相关的制约就越大，分支预测要有更高的准确度
  + 在n-流出的处理机中，遇到分支指令的可能性增加了n倍
  + 要给处理器连续提供指令，就需要准确地预测分支
+ 动态分支预测：在程序运行时，根据分支指令过去的表现来预测其将来的行为
  + 如果分支行为发生了变化，预测结果也跟着改变
+ 分支预测的有效性取决于
  + 预测的准确性
  + 预测正确和不正确两种情况下的分支开销
    + 决定分支开销的因素
      + 流水线的结构
      + 预测的方法
      + 预测错误时的恢复策略等
+ 动态分支预测的目的
  + 提高预测分支成功率
  + 尽快找到分支目标地址

### 分支历史表BHT
+ Branch History Table
  + 最简单的动态分支预测方法
  + 用BHT来记录分支指令最近一次或几次的执行情况（成功还是失败），并据此进行预测
+ 只有一个预测位的分支预测
  + 记录分支指令最近一次的历史，BHT中之需要1位二进制位
+ 采用两位二进制位来记录历史
  + 提高预测的准确度
  + 两位分支预测的性能与n位分支预测的性能差不多
  + 两位分支预测的状态转换，图略
  + 但是在之前的五段流水线中，哪怕是在ID段判断分支计算目标地址，BHT也仍然是在ID段执行的，没法带来什么好处

### 采用分支目标缓冲器BTB
+ 目标：将分支的开销降为0
+ 方法：分支目标缓冲
  + 将分支成功的分支指令地址和它的分支目标地址都放到一个缓冲区中保存起来，缓冲区以分支指令的地址作为标识
  + 这个缓冲区就是分支目标缓冲区Branch Target Buffer，或者分支目标cache

#### 采用BTB后，在流水线各个阶段所进行的相关操作
+ 当前PC值送存储器和BTB
+ BTB中存在匹配的项？（IF段）
  + ID段
  + 是：以BTB的第二字段作为分支目标地址送给PC
    + 当前分支成功？
      + EX段
      + 是：分支预测正确，继续执行后续指令，不会出现停顿
      + 否：分支预测错误，清除已取的指令，并从另一个分支（即失败处）取指令，从BTB中删除相应的项
  + 否：成功分支指令？
    + 是：将其PC值和目标地址写入BTB，作为一个新项（EX段）
    + 否：正常执行指令

#### 采用BTB后，各种可能情况下的延迟
|指令在BTB中？|预测|实际情况|延迟周期|
|:-----------|:--|:-------|:------|
|是|成功|成功|0|
|是|成功|不成功|2|
|不是| |成功|2|
|不是| |不成功|0|

#### BTB的另一种形式
在分支目标缓冲器中增设一个至少是两位的“分支历史表”字段，这样在BTB中如果查找到了对应项目，可以决定是否跳PC值。在原来的BTB中，一旦查找到了就一定跳PC值的。

## 多指令流出技术
+ 多流出处理机有两种基本风格
  + 超标量(SuperScalar)
    + 在每个时钟周期流出的指令条数不固定，依代码的具体情况而定（有上限）
    + 设这个上限为n，则该处理机为n流出
    + 可以通过编译器进行静态调度，也可以使用硬件动态调度
  + 超长指令字VLIW(Very Long Instruction Word)
    + 在每个时钟周期流出的指令条数是固定的，这些指令构成一条长指令或者一个指令包
    + 指令包中，指令之间的并行性是通过指令显式地表示出来的
    + 指令调度是由编译器静态完成的

### 基于静态调度的多流出技术
+ 在典型的超标量处理器中，每个时钟周期可以可以流出1到8条指令
+ 指令按序流出，在流出时进行冲突检测
  + 由硬件检测当前流出的指令之间是否存在冲突以及当前流出的指令与正在执行的指令是否有冲突

##### e.g. 一个4流出的静态调度超标量处理机
+ 在取指令阶段，流水线将从取指令部件收到1~4条指令（称为流出包）
  + 在一个时钟周期内，这些指令有可能式全部能流出，也可能只有一部分能流出
+ 流出部件检测结构冲突或数据冲突
  + 第一阶段：进行流出包内的冲突检测，选出初步判定可以流出的指令
  + 第二阶段：检测所选出的指令与正在执行的指令是否有冲突

##### MIPS处理机实现超标量
假设，从每个时钟皱隆起流出两条指令，一条整型指令和一条浮点指令
+ 要求： 同时取两条指令（64位），译码两条指令（64位）
+ 对指令的处理包括以下步骤
  + 从cache中取两条指令
  + 确定哪几条指令可以流出（0~2）条指令
  + 把它们发送到响应的功能部件
+ 双流出超标量流水线中指令执行的时空图
  + 假设：所有浮点指令的执行时间都是两个时钟周期（相当于比整型指令多了一个时钟周期）
+ 采用“1条整型指令+1条浮点指令”并行流出的方式，需要增加的硬件很少
+ 浮点load或浮点store指令将使用整型部件，回增加对浮点寄存器的访问冲突
  + 增设一个浮点寄存器的读/写端口
+ 由于流水线中的指令多了一倍，定向路径也要增加
+ 限制超标量流水线的性能发挥的障碍
  + load指令：load后续三条指令都不能使用其结果，否则就会引起停顿
  + 分支延迟
    + 如果分支指令是流出包中的第一条指令，则其延迟是3条指令
    + 否则就是流出包中的第二条指令，其延迟就是2条指令

### 超长指令字技术
+ 把能并行执行的多条指令组装称一条很长的指令
+ 设置多个功能部件
+ 指令字被分割成一些字段，每个字段称为一个操作槽，直接独立地控制一个功能部件
+ 在VLIW处理机中，在指令流出时不需要进行复杂的冲突检测，而是依靠编译器全部安排号了
+ 存在的问题
  + 程序代码长度增加了
    + 提高并行性而进行的大量的循环展开
    + 指令字中的操作槽并非总能填满
      + 解决：采用指令共享立即数字段的方法，或者采用指令压缩存储、调入cache或译码时展开的方法
  + 采用了锁步机制
    + 任何一个操作部件出现停顿时，整个处理机都要停顿
  + 机器代码的不兼容性

### 多流出处理器受到的限制
+ 程序所固有的指令级并行性
+ 硬件实现上的困难
+ 超标量和超长指令字处理器固有的技术限制

### 超流水线处理机
+ 将每个流水段进一步细分，这样在一个时钟周期内能够分时流出多条指令，这种处理机称为超流水线处理机
+ 对于一台每个时钟周期都能流出n条指令的超流水线计算机来说，这n条指令不是同时流出的，而是每隔1/n个时钟周期流出一条指令
  + 实际上该超流水线计算机长度流水线周期为1/n个时钟周期
+ 有时候把指令流水线级数位8及以上的流水线处理机称为超流水线处理机

# 存储系统
## 存储系统的基本知识
### 存储系统的层次结构
采用多种存储技术，构成多级存储层次结构
+ 程序访问的局部性原理：对于绝大多数程序来说，程序锁访问的指令和数据在地址上不是均匀分布的，而是相对簇聚的
+ 程序访问的局部性包含两个方面
  + 时间局部性：程序马上将要用到的信息很可能就是现在正在使用的信息
  + 空间局部性：程序马上将要用到的信息很可能与现在正在使用的信息在存储空间上是相邻的
+ 原理：加快经常性事件

#### 层次结构存储器
+ 假设第i个存储器$M_i$的访问时间为$T_i$，容量为$S_i$，平均每位价格为$C_i$，则
  + 访问时间$T_1 < T_2 < ... < T_n$
  + 容量$S_1 < S_2 < ... < S_n$
  + 平均每位价格$C_1 > C_2 > ... > C_b$

### 存储层次的性能参数
当整个存储系统只有两个层次M1，M2时候
+ 存储容量
  + 一般来说，整个存储系统的容量只用算第二级存储器M2的容量，即S=S2
+ 每位价格C
  + $C = \frac{C_1S_1 + C_2S_2}{S_1 + S_2}$
  + 当$S_1 << S_2$时,$C \approx C_2$
+ 命令率H和不命中率F
  + 命中率：CPU访问存储系统时，在M1中找到所需信息的概率
    + $H=\frac{N_!}{N_1 + N_2}$
    + N1：访问M1的次数
    + N2：访问M2的次数
  + 不命中率F：F = 1 - H
+ 平均访问时间$T_A$
  + $T_A = HT_1 + (1 - H) * (T_1 + T_M) = T_1 + (1 - H) T_M$
  + 或者$T_A = T_1 + FT_M$
  + 当命中时，访问时间即为$T_1$
  + 当不命中时，miss开销$T_M = T_2 + T_B$：从向M2发出访问请求到把整个数据块调入M1锁需要的时间
    + $T_B$为传入一个信息块所需的时间
  + 不命中时的总访问时间为$T_1 + T_2 + T_B$

### 三级存储系统
+ 三级
  + cache
  + 主存
  + 外存（辅存）
+ 可以看成是由cache-主存和主存-辅存层次构成的系统

| | cache-主存 | 主存-辅存 |
|:-|:--|:--|
|目的|为了弥补主存速度的不足|为了弥补主存容量的不足|
|存储管理实现|主要由专用硬件实现|主要由软件实现|
|访问速度的比值（一级比二级）|几比一|几万比一|
|典型的块（页）大小|几十个字节|几百到几千个字节
|CPU对第二级的访问方式|可直接访问|均通过第一级|
|不命中时CPU是否切换|不切换|切换到其它进程|

### 存储层次的四个问题
+ 当把一个块调入高一层（靠近CPU）存储器时，可以放在哪些位置上？ —— 影响规则
+ 当所要访问的块在高一层存储器中时候，如何找到该块？ —— 查找算法
+ 当发生不命中时，应替换哪一块？ —— 替换算法
+ 当进行写访问时，应进行哪些操作？ —— 写策略

## cache基本知识
### 基本结构和原理
+ cache是按块进行管理的
+ cache和主存均被分割称大小相同的块（cache line）
+ 信息以块为单位调入cache
  + 主存块地址（块号）用于查找该块在cache中的位置
  + 块内位移用于确定所访问的数据在该块中的位置
  + 主存地址：块地址+块内位移

### 映像规则
+ 全相联映像
  + 全相联：主存中的任意块可以被放置到cache中的任意一个文职
  + 特点：空间利用率最高，冲突概率最低，实现最复杂，查找速度慢
+ 直接映像：主存中断每一块只能被防止到cache中的位移一个位置
  + 特点：空间利用率最低，冲突概率最高，实现最简单，查找速度最快
  + 对于主存的第i块，若它映像到cache的第j块，则$j = i mod (M)$，其中M为cache的块数
  + 当$M=2^m$时，则当表示为二进制数时，j实际上就是i的低m位
+ 组相联映像
  + 组相联：主存中的每一块可以被防止到cache中唯一的一个组中的任何一个位置（直接映像到组，组内全相联）
  + 组相联是直接印象和全相联的一种折中
  + 组的选择
    + 若主存低i块映像到低k组，则$k = i mod (G)$
    + 设$G=2^g$，当二进制表示的时候，k实际上就是i的低j位
  + n路组相联：每组中有n个块($n = M \div G$)
    + n称为相联度
    + 相联度越高，cache空间的利用率就越高，块冲突概率就越低，不命中概率也就越低

### 查找算法
+ 通过查找目录表来实现
  + 目录表的结构
    + 主存块的块地址的高位部分，称为标识Tag
    + 每个主存块嫩巩唯一地由其标识来确定
  + 只需查找候选位置所对应的目录表项
+ 并行查找的实现方法
  + 相联存储器
    + 目录由$2^g$个相联存储区域构成，每个相联存储区的大小为$n \times (h + log_2 n)$位
    + 根据所查找到的组内块地址，从cache存储体中读出的多个信息字中选一个，发送给CPU
  + 但体多字的按地址访问的存储器和比较器

### 替换算法
+ 解决的问题：当新调入一块时，二cache有已经被占满时，如何替换
  + 直接映像的cache中替换很简单，因为只有一个
+ 替换算法
  + 随机
  + 先进先出FIFO
    + **FIFO中，不管一个块是否命中，只要是先进入的块，就一定先出去**
  + 最近最少使用发LRU
    + 选择近期最少被访问的块作为被替换的块
    + 实际上选择最久没有被访问过的块作为被替换的块
    + 优点：命中率较高

#### LRU算法的硬件实现——堆栈法
+ 用一个堆栈来记录组相联cache的同一组中各块被访问的先后次序
+ 用堆栈元素的物理位置来反映先后次序
  + 栈底记录最早被访问的块，栈顶记录刚访问过的块
  + 当需要替换时，从栈底得到应该被替换的块
+ 栈中的内容必须动态更新
  + 当cache访问命中时，通过用块地址进行相联查找，在堆栈中找到相应的元素，然后把该元素的上面的所有元素下压一个位置，同时把本次访问呢的块地址抽出来，从最上面压入栈顶。而该元素下面的所有元素则保持不动。
  + 如果cache访问不命中，则把本次访问的块地址从最上面压入栈顶，堆栈中所有原来的元素都下移一个位置。如果cache中该组已经没有空闲块，就需要替换一个块。这时从栈底被挤出去的块地址就是需要被替换的块的块地址
+ 堆栈法所需要的硬件
  + 需要为每一组都设置一个项数于相联读相同的小堆栈，每一项的位数位$log_2n$位
+ 硬件堆栈所需的功能
  + 相联比较
  + 能全部下移、部分下移和从中间取出一项的功能
+ 速度低，成本高，只适用于相联度较小的LRU算法

### 写策略
+ 占的访存比例不大，但是影响力很大
+ 写操作必须在确认是命中后才可以进行
+ 写访问有可能导致cache和主存内容的不一致
+ 两种写策略
  + 写直达法（写穿）：执行写操作时，不仅写入cache，而且也写入下一级存储器
  + 写回：执行写操作时，只写入cache，仅当cache中相应的块被替换时，才写回主存
  + 写策略是区分不同cache设计方案的一个重要标志
+ 两种写策略的比较
  + 写回：速度块，所使用的存储器带宽低
  + 写穿：易于实现，一致性好
+ 采用写穿法的时候，若在进行写操作，CPU必须等待，直到写操作结束，称为CPU写停顿
  + 减少些停顿的一种常用的优化技术：采用写缓冲器
+ 写操作时的调块
  + 按写分配（写时取）
    + 写不命中时，先把所写单元所在的块调入cache，再行写入
  + 不按写分配（绕写法）
    + 写不命中时，直接写入下一级存储器而不调块
+ 写策略与调块
  + 写回——按写分配
  + 写穿——不按写分配

### cache的性能分析
+ 不命中率
  + 与硬件速度无关
+ 平均访存时间
  + 平均访存时间 = 命中时间 + 不命中率 * 不命中开销
+ 程序执行时间
  + CPU时间 = （CPU执行周期数 + 存储器停顿周期数） * 时钟周期时间
  + 存储器停顿时钟周期数 = “读”的次数 * 读不命中率 * 读不命中开销 + “写”的次数 * 写不命中率 * 写不命中开销
  + = 访存次数 * 不命中率 * 不命中开销
  + CPU时间 = IC * （CPI + 访存次数 / 指令数 * 不命中率 * 不命中开销） * 时钟周期时间
  +  = IC * （CPI + 每条指令的平均访存次数 * 不命中率 * 不命中开销） * 时钟周期时间


## 降低cache不命中率
### 三种类型的不命中
+ 强制性不命中
  + 当第一次访问一个块时，该块不在cache中，需从下一级存储器中调入cache，这就是强制性不命中（冷启动不命中，首次访问不命中）
+ 容量不命中
  + 如果程序执行时所需的块不能全部调入cache中，则当某些块被替换后，若又重新被访问，就会发生不命中。
+ 冲突不命中
  + 在组相联或直接映像cache中，若太多的块映像到同一组（块）中，则回出现该组中某个别块被别的块替换（即使别的组或块又空闲位置），然后又被重新访问的情况。（碰撞不命中）

+ 结论
  + 相联度越高，冲突不命中越少
  + 强制性不命中和容量不命中不受相联度的影响
  + 强制性不命中不受cache容量的映像
  + 容量不命中随着容量的增加而减少
+ 减少三种不命中的方法
  + 强制性不命中：增加块大小，预取（本身很少）
  + 容量不命中：增加容量（成本、抖动现象）
  + 冲突不命中：提高相联度（理想情况、全相联）
+ 许多降低不命中率的方法回增加命中时间或不命中开销

### 增加cache块大小
+ 不命中率与块大小的关系
  + 对于给定的cache容量，当块大小增加时，不命中率开始下井，后来反而上升了
  + 原因
    + 一方面减少了强制性不命中
    + 另一方面，增加块大小回减少cache中的块的数目，所以增加冲突不命中
  + cache容量越大，使不命中率达到最低的块大小就越大
+ 增加块大小：增加冲突，增加不命中开销

### 增加cache的容量
+ 增加成本
+ 可能增加命中时间
+ 一般在片外cache中用得比较多

### 提高相联度
+ 采用相联度超过16的方案实际意义不大
+ 2:1cache经验规则
  + 容量位N的直接映像，cache的不命中率和容量位N/2的两路组相联cache的不命中率差不多相同
+ 提高相联度是以增加命中时间位代价的

### 伪限量cache（列相联cache）
多路组相联的低命中率和直接映像的命中速度
| | 优点 | 缺点 |
|:--|:--|:--|
|直接映像|命中时间小|不命中率高|
|组相联|不命中率低|命中时间长|

+ 伪相联cache的优点
  + 命中时间小
  + 不命中率低
+ 基本思想及工作原理
  + 在逻辑上把直接映像cache的空间上下分为两个区，对于任何一次访问，伪相联cache先按直接映像cache的方式去处理，若命中，则其访问过程与直接映像cache的情况一样。若不命中，则再去零一去相应位置去查找。若找到，则发生了伪命中，否则就只好访问下一级存储器。
+ 快速命中与慢速命中
  + 要保证绝大多数命中都是快速命中
+ 缺点：多种命中时间->CPU流水线复杂化

### 硬件预取
+ 指令和数据都可以预取
+ 预取内容既可以放入cache，也可放在外缓冲器中
+ 指令预取通常由cache之外的硬件完成
+ 预取利用存储器的空闲带宽，不能影响对正常不命中的处理，否则可能会降低性能

### 编译器控制的预取
在编译时加入预取指令，在数据被用到之前发出预取请求
+ 按照预取数据所存放的位置，可以把预取分为两种类型
  + 寄存器预取：把数据取到寄存器中
  + cache预取：指将数据取到cache中
+ 按照预取的处理方式不同，可把预取分为
  + 故障性预取：在预取时，若出现虚地址故障或违反保护权限，就会发生异常
  + 非故障性预取：在遇到这种情况时则不会发生异常，因为这是它会放弃预取，转变为空操作
+ 在预取数据的同时，处理器应能继续执行，只有这样预取才又意义（非阻塞，不锁定cache）
+ 编译器控制预取的目的：使执行指令和读取数据能重叠执行
+ 每次预取需要花费一条指令的开销
  + 保证这种开销不超过预取所带来的收益
  + 避免不必要的预取（预取准，何时预取）

### 编译器优化
+ 基本思想：通过对软件进行优化来降低不命中率
+ 程序代码和数据重组
  + 可以重新组织程序而不映像程序的正确性
    + 把一个程序中的过程重新排序，就可能会减少冲突不命中
    + 把基本块对齐，使得程序的入口点与cache块的起始位置对齐，就可以减少顺序代码执行时所发生的cache不命中的可能性（提高大cache块的效率）
  + 如果编译器知道一个分支指令很可能成功转移，那么就可以通过两步来改善空间局部性
    + 把转移目标出的基本快和紧跟着该分支指令后的基本快进行对调
    + 把该分支指令转换为操作语义相反的分支指令
  + 数据对存储位置的限制更少，更便于调整数据

### “牺牲”cache
+ 基本思想
  + 在cache和它从下一级存储器调数据的通路之间设置一个全相联的小cache，称为“牺牲”cache，用于存放被替换出去的块（称为牺牲者），以备重用

## 减少cache不命中开销miss penalty
### 采用两级cache
+ 性能分析
$$ 平均访存时间 = 命中时间_{L1} + 不命中率_{L1} * 不命中开销_{L1} $$
$$ 不命中开销_{L1} = 命中时间_{L2} + 不命中率_{L2} * 不命中开销_{L2} $$
+ 局部不命中率与全局不命中率
  + 局部不命中率 = 该级cache的不命中次数 / 到达该级cache的访问次数
  + 全局不命中率 = 该级cache的不命中次数 / CPU发出的访存的总次数
  + $全局不命中率_{L2} = 不命中率_{L1} * 不命中率_{L2}$
  + 评价第二级cache的时候，应使用全局不命中率这个指标。它指出了在CPU发出的访存中，究竟又多大比例是穿过各级cache，最终到达存储器的。
+ 采用两级cache时候，每条指令的平均访存停顿时间
  + $每条指令的平均访存停顿时间 = 每条指令的平均不命中次数_{L1}*命中时间_{L2} + 每条指令的平均不命中次数_{L2}*不命中开销$

### 第二级cache的参数
+ 容量
  + 第二级cache的容量一般比第一级大许多
+ 相联度
  + 第二级cache可采用较高的相联度或伪相联方法
+ 块大小
  + 第二季cache采用较大的块
  + 为减少平均访存时间，可以让容量较小的第一级cache采用较小的块，而容量较大的第二级cache采用较大的块

### 让读不命中优先于写
写缓冲器：在写穿法的时候，一般也不是直接把数据写到内存上，而是写到一个写缓冲器中，等CPU写完以后写缓冲器中的内容又再写到主存上。但是这样会带来问题：
+ cache中的写缓冲器导致存储器访问的复杂化
  + 在读不命中时，所读单元的最新值有可能还在写缓冲器中，尚未写入主存
+ 解决方法（读不命中的处理）
  + 推迟对读不命中的处理，直至写缓冲器清空（缺点：读不命中的开销增加）
  + 检查写缓冲器的内容（没有冲突就继续读）

### 写缓冲合并
写穿cache。依靠写缓冲来减少对下一级存储器写操作的时间。
+ 如果写缓冲器为空，就把数据和相应地址写入该缓冲器
+ 把这次的写入地址于写缓冲器中已有的所有地址进行比较，看是否有匹配的项。如果有地址匹配而对应的位置又是空闲的，就把这次要写入的数据于该项合并，就叫做写缓冲合并

### 请求字处理技术
+ 请求字
  + 从下一级存储器调入cache的块中，只有一个字是立即需要的，这个字称为请求字
+ 应尽早把请求字发送给CPU
  + 尽早重启动：调块时，从块的起始位置开始读起，一旦请求字到达，就立即发送给CPU，让CPU继续执行
  + 请求字优先：调块时，从请求字所在的位置

### 非阻塞cache技术
+ 非阻塞cache：cache不命中中时仍然允许CPU进行其它的命中访问
+ 进一步提高性能
  + 多重不命中下命中
  + 不命中下不命中

## 减少命中时间
### 虚拟cache
+ 物理cache
  + 使用物理地址进行访问的传统cache
  + 表示存储器中存放的是物理地址，进行地址检测也是用物理地址
  + 缺点：地址转换和访问cache串行进行，访问速度很慢
+ 虚拟cache
  + 可以直接用虚拟地址进行访问的cache，表示存储器中存放的是虚拟地址，进行地址检测用的也是虚拟地址
  + 优点：再不命中时不需要进行地址转换，省去了地址转换的时间。即使不命中，地址转换和访问cache也是并行进行的，起速度比物理cache块很多
  + 清空问题
    + 解决方法：再地址标识中增加PID字段（进程标识符）
+ 虚拟索引 + 物理标识
  + 优点：兼等虚拟cache和物理cache的好处
  + 局限性：cache容量受到限制

### cache访问流水化

## cache优化方法总结
+ 增加块大小
  + 减少强制不命中
  + 增加容量和冲突不命中，增加不命中开销
+ 增加cache容量
  + 增加命中时间，增加能耗
+ 增加相联度
  + 减少冲突不命中
  + 增加命中时间，增加能耗
+ 多级cache
  + 降低不命中时间，优化平均访问时间
+ 让读不命中优先于写
  + 降低不命中开销
+ 虚拟cache
  + 减少命中时间

## 虚拟存储器
### 基本原理
+ 页式存储器把空间划分为大小相同的块
+ 段式存储器把空间划分为可变长的块
+ 页是对空间的机械化分，而段是按程序的逻辑意义进行划分

### 快速地址转换技术
+ 地址变换缓冲器TLB
  + TLB是一个专用的告诉缓冲器，用于存放近期经常使用的页表项
  + TLB中的内容是页表部分内容的一个副本
  + TLB也利用了局部性原理
+ TLB中的项由两部分构成：标识和数据
  + 标识中存放的是虚地址的一部分
  + 数据部分中存放的则是物理页帧号、有效位、存储保护信息、使用位、修改位等

# 输入输出系统
## I/O系统的性能
+ 输入输出系统简称I/O系统
  + I/O设备
  + I/O设备与处理机的连接
+ I/O系统是计算机系统中的一个重要组成部分
  + 完成计算机与外界的信息交换
  + 给计算机提供大容量的外部存储器
+ 按照主要完成的工作进行分类
  + 存储I/O系统
  + 通信I/O系统
+ 评价I/O系统性能的参数
  + 连接特性
    + 哪些I/O设备可以和计算机系统相连接
  + I/O系统的容量
    + I/O系统可以容纳的I/O设备数
  + 响应时间和吞吐率等
+ 系统的响应时间（衡量计算机系统的一个更好的指标）
  + 从用户输入命令开始，到得到结果所花费的时间
  + 由两部分构成
    + I/O系统的响应时间
    + CPU的处理时间
  + 多进程技术只能够提供高系统吞吐率，并不能够减少系统响应时间
+ 另一种衡量I/O系统性能的方法：考虑I/O操作对CPU执行的打扰情况
  + 即考察由于其它进程的I/O操作，使得某个进程的执行时间增加了多少
+ I/O系统对CPU的性能影响很大，若两者的性能不匹配，I/O系统就有可能成为整个系统的瓶颈

## I/O系统的可靠性、可用性和可信性
+ 反映外设可靠性能的参数
  + 可靠性
  + 可用性
  + 可信性
+ 系统的可靠性：系统从某个初始参考点开始一直连续提供服务的能力
  + 用平均无故障时间MTTF来衡量
  + MTTF的倒数就是系统的失效率
  + 如果系统中每个模块的生存期服从指数分布，则系统整体的失效率是各部件的失效率之和（串联模式下）
  + 系统中断服务的时间用平均修复时间MTTR来衡量
+ 系统的可用性：系统正常工作的时间在连续两次正常服务间隔时间中所占的比率
  + 可用性 = $\frac{MTTF}{MTTF + MTTR}$
  + 平均失效间隔时间MTBF: MTTF + MTTR
+ 系统的可信度：服务的质量。即在多大程度上可以合理地认为服务是可靠的
+ 提高系统组成部件可靠性的方法
  + 有效构建方法
    + 在构建系统的过程中消除故障隐患，这样建立起来的系统就不会出现故障
  + 纠错方法
    + 在系统构建中采用容错的方法，这样即使出现故障，也可以通过容错信息保证系统正常工作

### 可靠性模型
可靠度`R(t)`，不可靠度`F(t)`，关系: $R(t) + F(t) = 1$
+ 串联系统
  + 系统由n个部件串联而称，其中任何一个部件失效就引起系统的失效
  + 串联系统寿命等于其中最先失效部件的寿命
  + 若每个单元的可靠度分别为$R_1, ..., R_n$，且每个单元相互独立，则系统可靠度为$R_s = \prod _{i=1}^n R_i$
  + 想要提高串联系统的可靠性，就要提高单元可靠度，减少串联单元数目
+ 并联系统
  + 系统由n个部件并联而称，当这n个部件都失效时才引起系统失效
  + 并联系统寿命等于其中最后失效部件的寿命
  + 若每个单元的可靠度分别为$R_1, ..., R_n$,且每个单元相互独立，则系统可靠度为$R_s = 1 - \prod _{i=1}^n (1-R_i)$
  + 想要提高并联系统可靠性，就要提高单元可靠度，增加并联单元数目
+ 串并联系统，n代表串联倍数，m代表并联倍数
  + $R(t) = 1 - [1-R_i^n(t)]^m$
  + e.g. RAID01是串并联系统
+ 并串联系统
  + $R(t) = [1-(1-R_i(t))^m]^n$
  + e.g. RAID10是并串联系统

## 廉价磁盘冗余阵列RAID
+ 磁盘阵列DA(Disk Array)：使用多个磁盘（包括驱动器）的组合来代替一个大容量的磁盘
  + 多个磁盘并行工作
  + 以条带为单位把数据均匀地分布到多个盘上（交叉存放）
  + 条带存放可以使多个数据读/写请求并行地被处理，从而提高总的I/O性能
+ 并行性的含义
  + 多个独立的请求可以由多个盘来并行的处理
    + 减少了I/O请求的排队等待时间
  + 如果一个请求访问多个块，就可以由多个盘合作来并行处理
    + 提高了单个请求的数据传输率
+ 问题：阵列中磁盘数量的增加会导致磁盘阵列的可靠性下降
  + 如果使用了N个磁盘构成磁盘阵列，那么整个整列的可靠性将降低为单个磁盘的1/N
  + 解决方法：在磁盘阵列中设置冗余信息盘
    + 当单个磁盘失效时，丢失的信息可以通过冗余盘中的信息重新构建
+ 大多数磁盘阵列的组成可以由以下两个特征来区分
  + 数据交叉存放的粒度
    + 细粒度磁盘阵列是在概念上把数据分割称相对较小的单位交叉存放
      + 优点：所有I/O请求都能够获得很高的数据传输率
      + 缺点：在任何时间，都只有一个逻辑I/O在处理当中，而且所有的磁盘都会因为每个请求进行定位而浪费时间
    + 粗粒度磁盘阵列是把数据以相对较大的单位交叉存放
      + 多个较小规模的请求可以同时得到处理
      + 对于较大规模的请求有能获得较高的传输率
  + 冗余数据的计算方法以及在磁盘阵列中的存放方式
+ 在磁盘阵列中设置冗余信息需要解决以下两个问题
  + 如何计算冗余信息
    + 大多采用奇偶校验码
    + 也有采用汉明码或者reed-solomon码的
  + 如何把冗余信息分布到磁盘阵列中的各个盘
    + 把冗余信息集中存放在少数的几个盘中
    + 把冗余信息均匀地存放到所有盘中
+ RAID的分级及其特性
| RAID级别 | 可以容忍的故障个数&数据盘为8时需检测盘的个数 | 优点 | 缺点 | 公司产品 |
|:--|:--|:--|:--|:--|
|0，非冗余，条带存放|0个故障；0个检测盘|没有空间开销|没有纠错能力|广泛应用|
|1，镜像|1个故障；8个检测盘|不需要计算奇偶校验，数据恢复快，读数据快。而且其小规模写操作比更高级别的RAID快|检测空间开销最大（需要的检测盘最多|EMC, HP, IBM|
|2，存储式ECC|1个故障；4个检测盘|不依靠故障盘进行自诊断|检测空间开销的级别是$log_2m$(m为盘的个数)|没有|
|3，位就校验|1个故障；1个检测盘|检测空间开销小（需要的检测盘少），大规模读写操作的带宽高|对小规模、随机读写操作没有提供特别的支持|外存概念|
|4，块交叉奇偶校验|1个故障；1个检测盘|检测空间开销小，小规模的读操作带宽更高|礁岩盘是小规模写的瓶颈|网络设备|
|5，块交叉分布奇偶校验|1个故障，1个检测盘|检测空间开销小，小规模的读写操作带宽更高|小规模写操作需要访问磁盘4次|广泛应用|
|6，P+Q双奇偶校验|2个故障；2个校验盘|具有容忍2个故障的能力|小规模写操作需要访问磁盘6次，检测空间开销加倍（与RAID3,4,5相比）|网络设备|

### RAID0
+ 非冗余磁盘真理，无冗余信息
+ 严格来说不属于RAID系列
+ 把数据切分称条带，以条带位单位交叉地分布存放到多个磁盘中
### RAID1
+ 镜像磁盘，对所有磁盘数据提供一份冗余的备份
  + 每当数据写入磁盘时，将该数据也写入其镜像盘。在系统中所有的数据都有两份
+ 特点
  + 能实现快速的读取操作
  + 对于写入操作，镜像的两个磁盘都要写入。但可以并行进行，而且不需要计算校验信息，所以其速度比某些级别的RAID快
  + 可靠性高，数据恢复很简单
  + 实现成本最高
### RAID2
+ 存储器式的磁盘阵列（按汉明码的思路构建）

### RAID3
+ 位交叉奇偶校验磁盘阵列
+ 特点
  + 采用奇偶校验
    + 写数据时，为每行数据形成奇偶校验位并写入校验盘
    + 读出数据时，如果控制器发现某个磁盘出故障，就可以根据故障盘意外的所有其它盘中的正确信息恢复故障盘中的数据（通过异或运算实现）
  + 细粒度的磁盘阵列，即采用的条带宽度较小（可以式一个字节或一位）
    + 多个磁盘的并行访问
    + 不能同时进行多个I/O请求的处理
  + 只需要一个礁岩盘，校验空间开销比较小
### RAID4
+ 块交叉就校验磁盘阵列
+ 采用比较大的条带，以块为单位进行交叉存放和计算奇偶校验
  + 实现目标：能同时处理多个小规模访问请求
+ 读写特点
  + 读取操作
    + 每次只需访问数据所在的磁盘
    + 仅在该磁盘出现故障时，才会去读礁岩盘，并进行数据重建
  + 写入操作
    + 假定：有3个数据盘和一个冗余盘
    + 写数据需要2次磁盘读和2次磁盘写操作

> RAID3,4存在的问题
> 每次读写都必须读写校验盘压力太大，会成为读写速度的瓶颈

### RAID5
+ 块交叉分布奇偶校验磁盘阵列
+ 数据以块交叉的方式存于各盘，无专用冗余盘，校验信息均匀分布在所有磁盘上
+ 重建与初始化
  + 重建：读出非故障盘上的数据，按照校验信息的计算方法得到故障盘上的数据，然后写入到新替换的盘上
  + 重构：重建的微观操作过程

#### 校验信息的正确完整性问题
+ 磁盘上初始信息式随机的
+ 满条块写和大写可以保证校验信息的正确
+ 若原始校验信息不正确，则小写不能保证校验信息的正确

#### RAID5初始化过程
+ 原则：保证校验信息一致正确
+ 方法：全部写0
+ 计算校验

### RAID6
+ P+Q双校验磁盘阵列
+ 特点
  + 校验空间开销是RAID5的两倍
  + 容忍两个磁盘出错
  + 应用越来越广

### RAID10和RAID01
+ RAID10又称RAID1+0，先进行镜像，再进行条带存放
+ RAID01先进行条带存放，再进行镜像

### RAID的实现与发展
+ 实现盘阵列的方式主要有三种
  + 软件方式：阵列管理软件由主机来实现
    + 优点：成本低
    + 缺点：过多地占用主机时间，且打款指标上不去
  + 阵列卡方式：把RAID管理软件固化在I/O控制卡上，从而可不占用主机时间，一般用于工作站和PC机
  + 子系统方式：一种基于通用接口总线的开放式平台，可用于各种主机平台和网络系统

## 总线
+ 在计算机系统中，各子系统之间可以通过总线互相连接
+ 优点：成本低、简单
+ 主要缺点：它是由不同的外设分时共享的，形成了信息交换的瓶颈，从而限制了系统中总的I/O吞吐量

### 总线的设计
+ 总线设计存在很多技术难点
  + 一个重要原因：总线上信息传送的速度极大地受限于各种物理因素，如总线的长度、设备数目、信号强度灯
  + 另外，我们一方面需要I/O操作响应快，另一方面又要提高吞吐量，这可能造成设计需求上的冲突
+ 设计总线时需要考虑的一些问题

|特性|高性能|低价格|
|:--|:--|:--|
|总线宽度|独立的地址和数据总线|数据和地址分时公用同一套总线|
|数据总线宽度|越宽越快|越窄越便宜|
|传输块大小|块越大总线开销越小|单字传送更简单|
|总线主设备|多个（需要仲裁）|单个（无需仲裁）|
|分离事务|采用一一分离的请求包和回答包能提高总线带宽|不采用一一持续连接成本更低，而且延迟更小|
|定时方式|同步|异步|

+ 分离事务总线（流水总线）
  + 在由多个主设备时，可以通过包交换来提高总线带宽
  + 基本思想
    + 将总线事务分成请求和应答两部分
    + 在请求和应答之间的空闲时间内，总线可以供其它的I/O使用，这样就不必再整个I/O过程中都独占总线
  + 分离事务总线有较高的带宽，但是它的数据传送延迟通常比独占总线方法大
+ 同步总线
  + 同步总线的控制线中包含一个时钟，总线上所有设备的所有通信操作都以该时钟为基准
  + 优点：速度快、成本低
  + 缺点：
    + 由于时钟通过长距离传输后会扭曲，因而同步总线不能用于长距离的连接，特别是对于告诉同步总线来说，更是如此
    + 总线上的所有设备都必须以同样的时钟频率工作
  + CPU-存储器通常采用同步总线
+ 异步总线
  + 没有同一的参考时钟，每个设备都有各自的定时方法
  + 采用握手协议
  + 不存在时钟扭曲和同步的问题，传输距离可以比较长
  + 很多I/O总线都采用异步总线
  + 同步总线通常比异步总线快
+ 总线标准和实例
  + I/O总线标准：定义如何将设备于计算机进行连接的文档

### 与CPU的连接
+ I/O总线的物理连接方式有两种选择
  + 连接到存储器上
  + 连接到cache上
+ I/O总线连接到存储器总线上的方式
  + 一种典型的组织结构
+ CPU对I/O设备的编址有两种方式
  + 存储器映射I/O（也成为I/O设备统一编址）
    + 将一部分存储器地址空间分配给I/O设备，用load指令和store指令对这些地址进行读写将引起I/O设备的数据传输
    + 将一部分存储空间流出用于设备控制，对这一部分地址空间进行读写就是向设备发出控制命令
  + 给I/O设备独立编址
    + 需要再CPU中设置专用的I/O指令来访问I/O设备
    + CPU需要发出一个标志信号来表示所访问的地址是I/O设备的地址
+ CPU与外部设备进行输入/输出的方式分为4种
  + 程序查询
  + 中断
  + DMA
  + 通道

### DMA和虚拟存储器
+ DMA使用虚拟地址还是物理地址？
  + 使用物理地址进行DMA传输，存在以下两个问题
    + 对于超过一页的数据缓冲区，由于缓冲区使用的页面在物理存储器中不一定是连续的，所以传输可能会发生问题
    + 如果DMA正在存储器和缓冲区之间传输数据时，操作系统从存储器中移出（或重定位）一些页面，那么，DMA将会在存储器中错误的页面上进行数据传输
  + 解决方法
    + 使操作系统I/O在传输过程中确保DMA设备所访问的页面都位于物理存储器中，这些页面被称为”钉在了主存中“
    + “虚拟DMA”技术
      + 允许DMA设备直接使用虚拟地址，并在DMA期间由硬件将虚拟地址转换为物理地址
      + 在采用虚拟DMA的情况下，如果进程在内存中被移动，操作系统应该能够及时地修改响应的DMA地址表

### I/O和cache数据一致性
+ Cache会使一个数据出现两个副本，一个在cache中，另一个在主存中
+ I/O设备可以修改存储器中的内容
  + 把I/O连接到存储器上， 会出现以下情况
    + CPU修改了cache的内容后，由于存储器的内容跟不上cache内容的变化，I/O系统进行输出操作时所看到的数据是旧值（写穿cache没有这样的问题）
    + I/O系统进行输入操作后，存储器的内容发生了变化，但CPU在cache中所看到的内容依然是旧值
+ 解决内容一致性问题的方法（不管cache是写穿还是写回）
  + 软件方法
    + 设法保证I/O缓冲器中的所有各块都不在cache中
    + 具体做法有两种
      + 把I/O缓冲器的页面设置为不可进入cache的，在进行输入操作时，操作系统总是把输入的数据放到该页面上
      + 在进行输入操作之前，操作系统先把cache中与I/O缓冲器相关的数据“赶出”cache，即把响应的数据块设置为无效状态
  + 硬件方法
    + 在进行输入操作时，检查响应的I/O地址（I/O缓冲器中的单元）是否在cache中（即是否有数据副本）
    + 如果发现I/O地址在cache中有匹配的项，就把响应的cache块设置为“无效”
  + 把I/O直接连接到cache上
    + 不会产生由I/O导致的数据不一致的问题
      + 所有I/O设备和CPU都能在cache中看到最新的数据
      + I/O会和CPU竞争访问cache，在进行I/O时，会造成CPU的挺短
      + I/O还可能会破坏cache中CPU访问的内容，因为I/O操作可能导致一些新数据被加入cache，而这些新数据可能在近期内并不会被CPU访问

## 可靠性基本理论
+ 可靠度
  + 可靠度参数(R(t))主要从一个系统能够正常工作的时间长短来描述系统可靠性
  + 定义为：系统在$t_0$时刻正常工作的条件下，在$[t_0, t]$时间区间正常工作的概率 $R(t) = p \{X > t\}$
  + 不可靠度为$F(t) = 1 - R(t)$
+ 故障密度函数f(t)（失效密度）
  + 事后统计：到t时刻在单位时间内发生故障的产品数与最初产品总数之比。
  + $f(t) = \lim _{\Delta t -> 0} \frac{\Delta F(t)}{\Delta t} = F'(t) = -R'(t)$
+ 故障率$\lambda (t)$（失效率）
  + 事后统计：到t时刻在单位时间内发生故障的产品数与在时刻t时仍正常产品数之比
  + $\lambda (t) =\frac{f(t)}{R(t)} = \frac{F'(t)}{R(t)} = \frac{-R'(t)}{R(t)}$
+ 平均寿命MTTF，也记作E(T)
  + 产品寿命T的数学期望，是f(t)对事件的积分平均值
  + $E(T) = \int _0 ^{\inf} t \cdot f(t)dt = \int _0 ^{\inf} R(t)dt$
+ 在一个系统整个寿命周期中，系统失效率随时间的变化规律可以用浴盆曲线来描述
  + 第一阶段是早期故障期，又称调试期，随着调试进行，早期故障不断排除，进入第二阶段随机故障期，这一时间是正常工作时期，其失效率不随时间变化而变化。随着系统运行时间越来越长，失效率不断增大，系统进入损耗故障期
  + 随机故障期是系统实际使用期，也是系统可靠性建模和分析最关心的时期，这期间系统失效率基本稳定
  + 随机故障期系统的可靠度函数服从指数分布规律$R(t)=e^{-\lambda t}$
  + 若产品寿命T的故障密度函数为$f(t)=\lambda e^{- \lambda t}$，则称T服从参数为$\lambda$的指数分布
  + 这是系统可靠性建模和分析中很重要的一个特性和假设前提

> 公式整理
> 可靠度$R(t) = 1 - F(t) = e^{-\lambda t}$
> 不可靠度$F(t) = \int _0 ^t f(t)d(t) = 1-e^{-\lambda t}$
> 故障密度函数为$f(t) = \lambda e^{-\lambda t}$
> 故障率$\lambda (t) = \frac{f(t)}{R(t)} = \lambda$
> 平均寿命$MTTF = \int _0 ^{\inf} R(t)dt = \frac{1}{\lambda}$

### 串联系统
+ 假设n各部件的工作是相互独立的，第i个部件寿命为$T_i$，可靠度为$R_i=P\{T_i>t\}$，失效率为$\lambda _i(t)$
+ $T=min(T_1, ..., T_n)$
+ 可靠度$R(t) = P{T>t} = \pod R_i (t)$
+ 即可靠度$R(t) = \pod _{i=1}^k R_i(t)$
#### 指数分布
若各单元的寿命服从指数分布，则串联系统的寿命也服从于指数分布
+ 可靠度$R(t) = e^{-\lambda t}$
+ 不可靠度$F(t) = 1 - e^{-\lambda t}$
+ 故障密度函数$f(t) = \lambda e^{-\lambda t}$
+ 故障率$\lambda (t) = \sum \lambda_i (t) = \lambda$
+ 平均寿命$MTTF = E[T] = \frac{1}{\sum \lambda_i} = \frac{1}{\lambda}$ 

### 并联系统
+ 假设n各部件的工作是相互独立的，第i个部件寿命为$T_i$，可靠度为$R_i=P\{T_i>t\}$，失效率为$\lambda _i(t)$
+ $T=max(T_1, ..., T_n)$
+ 可靠度$R(t) = P{T > t} = 1-\pod (1 - R_i(t)) = \pod_{i=1}^m(1-R_i(t))$
+ 不可靠度$F(t) = \pod_{i=1}^m(F_i(t))$
#### 指数分布
若各单元寿命服从指数分布时，并联系统寿命**并不服从**指数分布。若个单元相同，则
+ 可靠度$R(t) = 1- (1$- e^{-\lambda_i t})^m$
+ 不可靠度$F(t) = (1-e^{-\lambda_i t})^m$
+ 故障密度函数$f(t) = F'(t)$
+ 故障率$\lambda (t) = \frac{f(t)}{R(t)} = \frac{F'(t)}{R(t)} = \frac{-R'(t)}{R(t)}$
+ 平均寿命$MTTF = \int _0^{\inf} 1-(1-e^{-\lambda_i t})^m dt = \frac{1}{\lambda}\sum_{i=1}^m \frac{1}{i}$

# 互联网络
互联网络是一种由开关元件按照一定的拓扑结构和控制方式构成的网络，用来实现计算机系统中节点之间的相互连接
+ 节点：处理器、存储模块或其它设备
+ 在拓扑上，互联网络为输入节点到输出节点之间的一组互联或影响
+ SIMD计算机和MIMD计算机的关键组成部分
+ 3大要素：互联结构，开关元件，控制方式

##### ICN目的与作用
+ 当前提高计算速度的主要措施，一是改进器件，二是多处理单元并行计算。ICN是供多处理单元传输数据的高速通路，对并行计算时间影响很大。
+ ICN的主要草所：置换(N-N)，广播(1-N)，选播(1-N')

## 互联网络的分类
+ 通用/专用网
  + 通用网（原用于计算机之间交换信息的普通网络）
  + 专用网（专用于并行计算系统各处理单元之间并行交换数据的特殊网络）
+ 串行/并行网
  + 串行网（多个节点的发送操作在时间上不能重叠）
  + 并行网（多个节点的发送操作在时间上可以重叠）
+ 同步/异步网（并行网再细分）
  + 同步网（多个节点必须朝同一方向、以同一距离、同时开始发送）
  + 异步网（多个节点可以朝不同方向、以不同距离、不同时开始发送，可能冲突）
+ 静态/动态网
  + 静态网（节点之间有固定连接，且在运行中不能改变的网络）
  + 动态网（节点之间的连接关系不固定，需通过开关导向或地址识别来确定当前的目的节点）

## 互联网络的结构参数与性能指标
### 互联网络的结构参数
+ 网络通常是用有向边或无向边连接有限个节点的图来表示
+ 互联网的主要特性参数有
  + 网络规模N：网络中节点的个数
    + 表示该网络所能连接的部件的数量
  + 节点度d：与节点相连接的边数（通道数），包括入度和出度
    + 进入节点的边叫入度
    + 从节点出来的边叫出度
  + 节点距离：对于网络中的任意两个节点，从一个节点触发到另一个节点终止所需要跨越的边数的最小值
  + 网络直径D:网络中任意两个节点之间距离的最大值
    + 网络直径应尽可能的小
  + 等分宽度b：把由N各节点构成的网络切成节点数相同(N/2)的两半，在各种切法中，沿切口边数的最小值
    + 线等分宽度：$B=b \times w$
      + w为通道宽度（用位表示）
      + 该参数主要反映了网络最大流量
  + 对称性：从任何节点看到的拓扑结构都相同的网络称为对称网络
    + 对称网络的实现比较容易，也容易编程

## 静态互联网络
+ 线性阵列：一种一维的线性网络，其中N各节点用N-1各链路连接成一行
  + 端节点的度：1
  + 其余节点的度：2
  + 直径：N-1
  + 等分宽度b：1
  + 线性阵列与总线的区别：
    + 总线式通过切换与其连接的许多节点来实现时分特性的
    + 线性阵列允许不同的源节点和目的节点对并行地使用其不同的部分
+ 环和带弦环
  + 环：用一条附加链路将线性阵列的两个端点连接起来而构成。可以单向工作，也可以双向工作
    + 对称
    + 节点的度：2
    + 双向环的直径：N/2
    + 单向环的直径：N-1
    + 环的等分宽度b：2
  + 带弦环
    + 增加的链路越多，节点度越高，网络直径就越小
+ 全连接网络：每个节点都和剩下的其它节点有直接连接
  + 节点的度：N-1
  + 直径：1
+ **循环移数网络**：通过在环上每个节点到所有与其距离位2的证书幂的节点之间都增加一条附加链而构成
  + 如果$|j - i| = 2^r$，则节点i与节点j连接
  + **节点的度**：2n-1，其中$n=log_2 N$
  + **直径**：$\lceil \frac{n}{2} \rceil$
  + 网络规模：$N=2^n$
+ 树形和星形
  + 树形：二叉树
  + 一棵k层完全平衡的二叉树有N=2k-1个节点
  + 最大节点度：3
  + 直径：2(k-1)
  + 等分宽度b=1
+ 星形
  + 最大节点度：N-1
  + 直径较小，是2
  + 等分宽度$b=\lfloor \frac{N}{2} \rfloor$
  + 可靠性交叉，中心节点处故障，这个系统就会瘫痪
+ 胖树形
+ 网格形和环网形
  + 网格形
    + 一个规模为$N=n \times n$的2维网格形网络
      + 内部节点的度：4
      + 边节点的度：3
      + 角节点的度：2
      + 网络直径D：2(n-1)
      + 等分宽度b：n
    + 一个由$N=n^k$个节点构成的k维网格形网络（每维n个节点）的内部节点度d=2k，网络直径D=k(n-1)
  + **Illiac网络**
    + 把2维网格形状网络的每一列的两个端节点连接起来，再把每一行的尾节点与下一行的头节点连接起来，并把最后一行的尾节点与第一行的头节点连接起来
    + 一个规模为$n \times n$的Illiac网络
      + 所有节点的度：4
      + 网络直径D：n-1
      + 等分宽度b：2n
  + 环网形
    + 把2维网格形网络的每一行的两个端点连接起来，把每一列的两个端节点也连接起来
    + 将环形和网格形组合再一起，并能向高维扩展
    + 一个规模为$n \times n$的环网形网
      + 节点度：4
      + 网络直径：$2 \times \lfloor \frac{n}{2} \rfloor$
      + 等分宽度b：2n

## 互连函数
变量x：输入

函数f(x)：输出

通过数学表达式简历输入端号与输出端号的连接关系。即在互连函数f的作用下，输入端x连接到输出端f(x)

互连函数反映了网络输入数组和输出数组之间对应的置换关系或排列关系

### 几种基本的互连函数
+ 恒等函数：实现同号输入端和输出端之间的连接
  + $I(x_{n-1}...x_1x_0) = x_{n-1}...x_1x_0$
+ 交换函数：实现二进制地址编码中第k位互反的输入端与输出端之间的连接
  + $E(x_{n-1}...x_{k+1}x_kx_{k-1}...x_0) = x_{n-1}...x_{k+1}\overline{x_k}x_{k-1}...x_0$
  + 主要用于构造立方体互连网络和各种超立方体互连网络
  + 共有$n=log_2 N$中互连函数（N位节点个数）
  + 当N=8，n=3时，可得到常用的立方体互连函数
    + $Cube_0(x_2x_1x_0)=x_2x_1\overline{x_0}$
    + $Cube_1(x_2x_1x_0)=x_2\overline{x_1}x_0$
    + $Cube_3(x_2x_1x_0)=\overline{x_2}x_1x_0$
+ 均匀洗牌函数：将输入端分成数目相等的两半，前一半和后一半按类似均匀混洗扑克牌的方式交叉地连接到输出端（输出端相当于混洗的结果）
  + 也称为混洗函数（置换）
  + $\sigma(x_{n-1}...x_0)=x_{n-2}...x_0x_{n-1}$
  + 即把输入端的二进制编号循环左移一位
  + $\sigma^{(n)}(X) = \sigma _{(n)}(X) = \sigma(X)$
  + $\sigma ^{(1)} = \sigma _{(1)}(X) = X$
  + 逆均匀洗牌函数：将输入端的二进制编号循环右移一位而得到所有连接的输出端编号
+ 碟式函数：把输入端的二进制编号的最高位于最低为互换位置，便得到输出端的编号
  + $\beta(x_{n-1}...x_1x_0) = x_0x_{n-2}...x_1x_{n-1}$
  + 第k个子函数：$\beta _{(k)}(x_{n-1}...x_kx_{k-1}x_{k-2}...x_1x_0)=x_{n-1}...x_kx_0x_{k-2}...x_1x_{k-1}$
    + 把输入端的二进制编号的低k位中的最高位与最低位互换
  + 第k个超函数：$\beta ^{(k)}(x_{n-1}x_{n-2}...x_{n-j+1}x_{n-k}x_{n-k-1}...x_1x_0)=x_{n-k}x_{n-2}...x_{n-k+1}x_{n-1}x_{n-k-1}...x_1x_0$
    + 把输入端的二进制编号位中的高k位中的最高位与最低位互换
  + $\beta ^{(n)}(X) = \beta _{(n)}(X) = \beta(X)$
  + $\beta ^{(1)} = \beta _{(1)}(X) = X$
+ 反位序函数：将输入端二进制编号的位序颠倒过来得相应输出端的编号
  + $\rho(x_{n-1}x_{n-2}...x_1x_0)=x_0x_1...x_{n-2}x_{n-1}$
  + 第k个子函数：$\rho _{(k)}(x_{n-1}...x_kx_{k-1}x_{k-2}...x_1x_0)=x_{n-1}...x_kx_0x_1...x_{k-2}x_{k-1}$
    + 把输入端的二进制编号的低k位中各位的次序颠倒过来
  + 第k个超函数：$\rho ^{(k)}(x_{n-1}x_{n-2}...x_{n-k+1}x_{n-k}x_{n-k-1}...x_1x_0)=x_{n-k}x_{n-k+1}...x_{n-2}x_{n-1}x_{n-k-1}...x_1x_0$
    + 把输入的那的二进制编号的高k位中各位的次序颠倒过来
  + $\rho ^{(n)}=\rho _{(n)}(X) = \rho(X)$
  + $\rho ^{(1)}(X) = \rho _{(1)}(X) = X$
+ 移数函数：将各输入端都错开一定的位置（模N）后连到输出端
  + $\alpha (x) = (x \pm k) mod N$
+ PM2I函数
  + P和M分别表示加和减，2I表示$2^i$
    + 即“加减$2^i$”函数
  + 移数函数的一种，将各输入端都错开一定的位置（模N）后连接到输出端
  + $PM2_{+i}(x) = x + 2^i mod N$
  + $PM2_{-i}(x) = x - 2^i mod N$
  + PM2I互连网络供有2n个互连函数


#### 子函数与超函数
+ 互联函数（设为s）的第k个子函数：把s作用于输入端的二进制编号位的底k位，记作$s_{(k)}$
+ 互联函数（设为s）的第k个超函数：把s作用于输入端的二进制编号位的高k位，记作$s^{(k)}$

#### 逆函数
对于任意一种函数f(x)，如果存在g(x)，使得$f(x) \times g(x) = I(x)$，则称g(x)是f(x)的逆函数，记作$f^{-1}(x)$

#### 单级ICN
+ 定义：单级ICN只使用一级开关。开关的每种接通组合方式可用一个互连函数表示
+ 在互连函数中，
  + N表示节点数
  + $n=log_2N$表示维数
  + $j=X_{n-1}...X_0$表示节点
  + 编号的二进制形式，位数位n

### 单级立方体网
+ 该网络由立方体函数定义，立方体函数族有n个成员，$Cube_0, ..., Cube_{n-1}$
+ 最坏情况下传输需对输入节点编号的全部n位取反，所以单级立方体网络直径是n，成本$N \cdot log_2 N$
+ 立方体函数性质：结合律、交换律以及自反律

### 单级混洗——交换网
+ 该网络由混洗函数与交换函数定义
+ 混洗函数定义
  + shuffle(j) = 2j mod (N-1), 当j < N-1
  + shuffle(j) = N-1, 当j = N-1
+ 网络直径是2n-1,成本$N \cdot 2$
> e.g. 当n=3的混洗网络还不足以构成一个连通图，所以还要加上一个$Cube_0$函数，才能偶构成完整的单级混洗——交换网络

### 单级加减$2^i$网
+ 该网络由PM2I函数定义，PM2I函数供有n对成员，分别是$PM2_{\pm 0}, PM2_{\pm 1}, ..., PM2_{\pm (n-1)}$
+ 性质1：对相同的i值，$PM2_{+i}$与$PM2_{-i}$函数的传送路径相同，方向相反
+ 性质2：$PM2_{+(n-1)} = PM2_{-(n-1)}$，所以单级PM2I网络实际只能实现2n-1种不同的置换
+ 单级PM2I网络的直径是$\lceil \frac{n}{2} \rceil$
+ 成本$N(2 \times log_2 N -1)$
+ 该网络包含多个强连通子图（即除去若干边以后仍能保证任何一对节点互相可达），所以这2n个函数并不是实现互联网的最小集合。实际应用中，可以使用他们的一个子集来构造互连网。

## 单级ICN寻径算法
符号约定：起点$x=x_{n-1}...x_0$，终点$y=y_{n-1}...y_0$
+ 单级立方体网
  + 二者间路径由地址逻辑差$y_i \oplus x_i$决定。若$y_i \oplus x_i==1$则代表$Cube_i$维需要走一步。各个维度先后顺序可任意安排。“1”的个数即位总步数
+ 单级混洗-交换网
  + 二者间路径也由地址逻辑差$y_i \oplus x_i$决定。如果$y_i \oplus x_i == 1$表明$x_i$必须先经过n-i步shuffle到最低位，1步$Cube_0$求反，再经i步shuffle回到原位变成$y_i$。如有多位“1”，可以合并shuffle。

## 动态互连网络
### 总线网络
+ 由一组导线和插座构成，经常被i用来实现计算机系统中处理机模块、存储模块和外围设备之间的互连。
  + 每一次总线只能用于一个源（主部件）到一个或多个目的（从部件）之间的数据传送
  + 多个功能模块之间的竞争总线或时分总线
  + 特点：
    + 结构简单、实现成本低、带宽较窄
+ 一种由总线连接的多处理机系统
  + 系统总线再处理机、I/O子系统、主存储器以及辅助存储设备（磁盘、磁带机）之间提供了一条公用通路
  + 设备总线通常设置再印刷电路板底板上。处理器板、存储器板和设备接口板都通过插座或电缆插入底板
+ 解决总线带宽较窄问题：采用多总线或多层次的总线
  + 多总线：设置多条总线
    + 为不同的功能设置专用的总线
    + 重复设置相同功能的总线
  + 多层次的总线式按层次的架构设置速度不同的总线，使得不同速度的模块有比较适合的总线连接

### 交叉开关网络
+ 单级开关网络
  + 交叉点开关能在对偶（源、目的）之间形成动态连接，同时实现多个对偶之间的无阻塞连接
  + 带宽和互连特性最好
  + 一个$n \times n$的交叉开关网络，可以无则色地实现$n!$中置换
  + 对一个$n\times n$的交叉开关网络来说，需要$n^2$套交叉开关以及大量的连线。
+ C.mmp多处理机的互连结构
  + 用16×16的交叉开关网络把16台处理机与16个存储模块连接在一起
  + 最多可同时实现16台处理机对16个不同存储模块的并行访问
    + 每个存储模块一次只能满足一台处理机的请求
    + 当多个请求要同时访问同一存储模块时，交叉开关就必须分解所发生的冲突，每一列只能接通一个交叉点开关。
    + 为了支持并行（或交叉）存储器访问，可以在同一行中接通一个交叉点开关

### 多级互连网络
MIMD和SIMD计算机都采用多级互连网络MIN(Multistage Interconnection Network)
+ 由a×b开关模块和级间连接构成的通用多级互连网络结构
+ 每一级都用了多个a×b开关
  + a个输入和b个输出
  + 在理论上，a和b不一定相等，然而实际上a和b经常选为2的整数幂，即$a=b=2^k$
  + 相邻各级开关之间都有固定的级间连接

#### 多级ICN
+ 定义：多级ICN使用多级开关，使得数据在一次通过网络的过程中可以实现的置换种类更多
+ 通常在N个节点的网络中，多级ICN由n级构成($n=log_2 N$)
+ 经典的多级互连网有多级立方体网、多级混洗-交换网和多级PM2I网
+ 多级立方体网和多级混洗-交换网不使用单级互联网中的那种多路选择开关而是用一种2输入/2输出的二元交换开关，以减少开关总数。二元交换开关基本接通状态有“直连”、“交换”、“上播”、“下播”，进行数据置换时只能使用前两种。
+ 各种多级互连网络的区别在于所用开关模块、控制方式和级间互连模式的不同
  + 控制方式：对各个开关模块的控制方式
    + 级控制：每一级所有开关只用一个控制信号控制，只能同时处于同一种状态。
    + 部分级控制：第i级的所有开关分别用i+1个信号控制
    + 单元空hi：每一个开关都有一个独立的控制信号，可各自处于不同的状态。各开关动作独立，性能比前两种方式都更灵活，结构也更复杂
  + 常用的级间互连模式
    + 均匀洗牌、碟式、多路洗牌、纵横交叉、立方体连接等

#### 多级混洗-交换网络
由n级构成，每一级包含一个无条件混洗拓扑线路和一列可控的二元交换开关，前后重复。各级编号是n-1,...,0，降序排列
+ 单独一级混洗拓扑线路可完成一次数据混洗
+ 单独一列二元交换开关在处于“交换”状态时可完成一次交换操作($Cube_0$)
+ 如果各级二元交换开关都处于“直连”状态，N个节点的数据通过网络仅经过n次混洗操作，排列顺序最终恢复输入状态（混洗函数性质2）
+ 如果各级二元交换开关都处于“交换”状态，则N个节点的数据在每次混洗之后紧接着一次交换($Cube_0$)，也就是地址码的最低位取反，最后n位地址均被取反

#### 多级混洗-交换网络寻径算法
+ 目的：根据给定的输入/输出对应关系，确定各开关的状态
+ 名称：源-目的地址异或法
+ 操作：将任意一个输入地址与它要到达的输出地址做异或运算，其结果的$bit_i$位控制数据到达的第i级开关。“0”表示“直连”，“1”表示“交换”

# 多处理器
### 并行计算机系统结构的分类
+ Flynn分类法
  + SISD,SIMD,MISD,MIMD
+ MIMD已称为通用多处理器系统结构的选择
  + MIMD具有灵活性
  + MIMD可以充分利用商品化微处理器在性能价格比方面的优势
> 多处理机系统是MIMD计算机的一种实现类型，也是已经商品化的MIMD的唯一形式。
> 多处理机系统由多态处理机连接而成，能够并行执行独立的程序模块，并且相互通信和同步，以实现作业、任务级的并行。
> MIMD计算机与SIMD计算机的主要区别，在于SIMD只能在同一时刻做多件相同的事情，而MIMD却可以在同一时刻做多件相同或不同的事情（多至零六所致），所以求解同一个问题时采用MIMD将能实现更大比例的并行操作，即处理效率更高。
> 从并行处理的级别看，SIMD是数据级并行处理，流水线是指令级并行处理，MIMD是任务级并行处理
+ 根据存储器的组织结构，把现有的MIMD机器分为两类
  + 集中式共享存储器结构
    + 最多由几十个处理器构成。各处理器共享集中式物理存储器。也称为
      + SMP机器 Symmetric Shared-memory Multiprocessor
      + UMA机器 Uniform Memory Access
  + 分布式存储器多处理机
    + 存储器在物理上是分布的。支持较大规模多处理机系统
    + 每个节点包含
      + 处理器，cache
      + I/O
      + 存储器
      + 互连网络接口
    + 在许多情况下，分布式存储器结构优于集中式共享存储器结构
    + 优点：
      + 如果大多数的访问是针对本节点的局部存储器，则可降低对存储器和互连网络的带宽要求
      + 对本地存储器的访问延迟时间小
    + 最主要缺点：处理器间的通信较复杂，且各处理器间访问延迟较大
    + 簇：超级节点
      + 每个节点内包含个数较少（2~8）的处理器
      + 处理器之间可采用另一种互连技术（如总线）相互连接形成簇

### 存储器系统结构和通信机制
+ 两种存储器系统结构
  + 共享地址空间
    + 物理上分离的所有存储器作为一个同一的逻辑空间进行编址。
    + 任何一个处理器可以访问该共享空间中的任何一个单元（具有访问权），而且不同处理器上的同一个物理地址指向的是同一个存储单元
    + 称为：分布式共享存储器系统(DSM: Distributed Shared-Memory)，NUMA机器(Non-Uniformed Memeory Access)
  + 把每个节点中的存储器编址位一个独立地址空间，不同节点中的地址空间是相互独立的
    + 整个系统的地址空间由多个独立的地址空间构成
    + 每个节点中的存储器只能由本地处理器访问，远程处理器不能直接对其进行访问
    + 每一个处理器-存储器模块实际上是一台单独计算机
    + 多以集群的形式存在
+ 通信机制
  + 共享存储器通信机制
    + 共享地址空间的计算机系统采用
    + 处理器间通过load/store指令对相同存储器地址读/写来实现
  + 消息传递通信机制
    + 多个独立地址空间的计算机采用
    + 通过处理器间显式地传递消息来完成
    + 消息传递多处理机中，处理器间通过发送消息通信，这些消息请求进行某些操作或者传送数据。
    + 当一个处理器要对远程存储器上的数据进行访问或操作时
      + 发送消息，请求传递数据或对数据进行操作（远程调用RPC, Remote Process Call）
      + 目的处理器接受到消息后，执行相应操作或代替远程处理器进行访问，并发送应答消息返回结果
    + 同步消息传递：请求处理器发送一个消息后一直要等到应答结果才继续运行
    + 异步消息传递：数据发送方知道别处理器需要数据，通信也可以从数据发送方开始，数据可不经请求就直接送往数据接收方
+ 不同通信机制的优点
  + 共享存储器通信
    + 与通常对称式多处理机的通信机制兼容
    + 易于变成，在简化编译器设计方面有优势
    + 采用大家熟悉的共享存储器模型开发应用程序，把重点放到解决对性能影响较大的数据访问上
    + 通信数据量较小时，通信开销较低，带宽利用较好
    + 可通过cache技术减少远程通信频度，减少通信延迟以及对共享数据访问冲突
  + 消息传递通信机制
    + 硬件较简单
    + 显式通信，更容易搞清何时发生通信以及通信开销是多少
    + 显式通信可让编程者重点注意并行计算的主要通信开销，使之有可能开发出结构更好、性能更高的并行程序
    + 同步很自然地与发送消息相关联，能减少不当同步带来错误的可能性

### 并行处理面临的挑战
+ 程序中的并行性优先
+ 相对较大的通信开销

多处理机加快运算速度的基本原理是并行计算，即把一个程序分成n等份交给n个处理机同时执行。但是实现难度较大。

1. 程序中总有一定比例的不可并行部分，如I/O操作
2. 划分开的个部分之间需要通信（同步、互斥），分得越细通信越频繁，而单处理机算法中几乎不需要通信（即使进程间需要通信，时间开销也小到可以忽略）
3. 多处理机分类中的多计算机系统的通信方式是机外传输，每次时间开销比机内开销大成百上千倍

对算法的要求：1. 较高的可并行化比例；2. 较低的进程间通信量

+ 问题的解决：  
  + 并行性不足：采用并行性更好的算法
  + 远程访问延迟的降低：考系统结构支持和编程技术

在并行处理中，影响性能（负载平衡、同步和存储器访问延迟等）的关键因素常依赖于：应用程序的高层特性，如数据的分配，并行算法的结构以及在空间和时间上对数据的访问模式等

依据特点可把多机工作负载大致分成两类：单个程序在多处理机上的并行工作负载&多个程序在多处理机上的并行工作负载

并行程序的计算/通信比率，是反映并行程序性能的一个重要度量。计算/通信比率随着处理数据规模的增大而增加，随着处理器数目的增加而减少。

## 对称式共享存储器系统结构
+ 多个处理器通过共享总线共享了一个存储器
+ 大容量、多级cache降低对内存带宽和总线带宽的要求
+ 支持对共享数据和私有数据cache的缓存
  + 私有数据供一个单独的处理器使用
  + 共享数据则是供多个处理器使用
+ 共享数据进入cache产生了一个新的问题
  + cache一致性问题

### 多处理机cache一致性
+ 多处理机的cache一致性问题
  + 允许共享数据进入cache，就可能出现多个处理器的cache中都有同一存储块的副本。
  + 当其中某个处理对其cache中的数据进行修改后，就会使得其cache中的数据与其它cache中的数据不一致
+ 存储器的一致性：如果对某个数据项的任何度操作均可得到其最新写入的值，则认为这个存储系统是一致的
  + 存储系统行为的两个不同方面
    + what：度操作得到的是什么值
    + when：什么时候才能将已写入的值返回给度操作
  + 存储器是一致的，当满足以下条件
    + 处理器P对单元X进行一次写之后又对单元X进行读，读和写之间没有其它处理器对单元X进行写，则P读到的值总是前面写进去的值
    + 处理器P对单元X进行写之后，零一处理器Q对单元X进行读，读和写之间无其它写，则Q读到的值应位P写进去的值
    + 对同意单元的写是串行化的，即任意两个处理器对同一单元的两次写，从各处理器的角度看来顺序都是相同的
  + 重要假设
    + 直到所有的处理器均看到了写的结果，这个写操作才算完成
    + 处理器的任何访存均不能改变写的顺序。即允许处理器对读进行重新排序，但必须以程序规定的顺序进行写。

### 实现一致性的基本方案
+ 在一致的多处理机中，cache提供两种功能
  + 共享数据的迁移：减少了对远程共享数据的访问延迟，也减少了对共享存储器带宽的要求
  + 共享数据的赋值：不仅减少了访问共享数据的延迟，也减少了访问共享数据所产生的冲突
  + 一般情况下，小规模对处理机是采用硬件的方法来实现cache的一致性
+ cache一致性协议：在多个处理器中用来维护一致性的协议
  + 关键：跟踪记录共享数据快的状态
  + 两类协议（采用不同技术跟踪共享数据状态）
    + 监听式协议(snooping)
      + 每个cache除了包含物理存储器中块的数据拷贝外，也保存着各块的共享状态信息
      + 所有cache都可以通过某种广播介质访问，所有cache控制器监听总线来判断它们是否有总线上请求的数据块
    + 目录式协议(directory)
      + 物理存储器中数据块的共享状态被保存位一个称为目录的地方。开销稍大于前者，但可用于实现更大规模的的多处理机。
+ 采用两种方法来解决cache一致性问题
  + 写作废协议：在处理器对某数据项写入之前，保证它拥有对该数据项的唯一访问权（作废其它副本）
  + 写更新协议：当一个处理器对某数据项进行写入时，通过广播使其它cache中所有对应于该数据项的副本进行更新
  + 性能差异
    + 在对同一个数据进行多次写操作而中间无操作时，写更新协议需进行多次广播，而写作废协议之需要一次作废操作
    + 在对同一cache块的多个字进行操作时，写更新协议对于每一个写操作都要进行一次广播，而写作废协议仅在对该块的第一次写时进行作废操作即可（写操作是针对cache块的，写更新则是针对字/字节）
    + 考虑从一个处理器A进行写操作后到另一个处理器B能都读到该写入数据之间的延迟时间（写更新协议的延迟时间较小）

### 监听协议的实现
+ 监听协议的基本实现技术
  + 实现写作废协议的关键：使用广播介质执行作废（假定采用的是总线）
    + 当一个处理器cache响应本地CPU访问时涉及全局操作，cache控制器需取得总线访问权后，在总线上发相应消息。
    + 所有处理器都一直在监听总线，检测总线上的地址是否在它们的cache中。若在，则相应处理。
  + 写操作的串行化：由总线实现（获取总线控制权的顺序性）
+ cache发送到总线上的消息主要有以下两种
  + RdMiss——读不命中
  + WtMiss——写不命中
  + 需要通过总线找到相应数据块的最新副本，然后调入本地cache中。
    + 写穿cache：因为所有写入的数据同时都被写回主存，所以从主存中总可以取到其最新的值
    + 写回cache：得到数据的最新值会困难一些，因为最新值可能在某个cache中，也可能在主存中（不用掌握）
  + 有的监听协议还增设了invalidate消息，用来通知其它各处理器作废其cache中相应的副本
    + 与WtMiss的区别：invalidate不引起调块
  + cache的标识(tag)可直接用来实现监听
  + 修改位——最新副本（写回法）
  + 作废一个块只需将其有效位置为无效
  + 给每个cache块增设一个共享位
    + “1”：该块是被多个处理器所共享
    + “0”：仅被某个处理器所独占
    + 块的拥有者：拥有该数据块的唯一副本的处理器
+ 监听协议距离
  + 在每个节点内嵌入一个有限状态控制器
    + 该控制器根据来自处理器或总线的请求以及cache块的状态，做出相应的响应
  + 每个数据块的状态取以下3种状态中的一种
    + 无效(Ivalid): cache中该块的内容为无效
    + 共享(Shared): 该块可能处于共享状态
      + 在多个处理器中都有副本，这些副本都相同，且与存储器中响应的块相同
    + 已修改(Modified): 该块已经被修改过，并且还没写入存储器（块中的内容是最新的，系统中唯一的最新副本）

## 分布式共享存储器系统结构
### 目录协议的基本思想
+ 广播和监听的机制使得监听一致性协议的可扩放性很差
+ 寻找替代监听协议的一致性协议

即使用目录协议 

+ 目录协议
  + 目录：一种集中的数据结构。对于存储器中的每一个可以调入cache的数据块，在目录中设置一条目录项，用于记录该块的数据状态以及那些cache中有副本等相关信息
  + 特点
    + 对于任何一个数据块，都可以快速地在唯一的一个位置中找到相关的信息。这使一致性协议避免了广播操作
  + 位向量：记录哪些cache中有副本
    + 每一位对应于一个处理器
    + 长度与处理器的个数成正比
    + 由位向量指定的处理机的集合称为共享集S
  + 分布式目录
    + 目录与存储器一起分布到各结点中，从而对于不同目录内容的访问可以在不同的节点进行。
  + 最简单的实现方案：对于存储器中每一块都在目录中设置一项。目录中的信息量与M×N成正比。
    + M：存储器中存储块的总数
    + N：处理器的个数
    + 由于M=K×N，K是每个处理器中存储块的数量，所以如果K保持不变，则目录中的信息量就与$N^2$成正比
+ 在目录协议中，存储块的状态有3种
  + 未缓冲：该块尚未被调入cache，所有处理器的cache中都没有这个块的副本
  + 共享：该块在一个或多个处理机上有这个块的副本， 且这些副本与存储器中的该块相同。
  + 独占：仅有一个处理机有这个块的副本，且该处理机已经对其进行了写操作，所以其内容是最新的，而存储器中该块的数据已经过时。
+ 本地节点、宿主节点以及远程节点的关系
  + 本地节点：发出访问请求的节点
  + 宿主节点：包含所访问的存储单元及其目录项的节点
  + 远程节点：包含cache block的副本
+ 在节点之间发送的消息
  + 本地节点发给宿主节点（目录）的消息
    + P：发出请求的处理机编号，K：所要访问的地址
    + RdMiss(P, K): 处理机P读取地址位K的数据时不命中，请求宿主节点提供数据（块），并要求把P加入共享集
    + WtMiss(P, K): 处理机P对地址K进行写入不命中，请求宿主节点提供数据，并使P成为所访问数据块的独占者
    + Invalidate(K): 请求向所拥有响应数据块副本（包含地址K）的远程cache发Invalidate消息，作废这些副本。
  + 宿主节点（目录）发送给远程节点的消息
    + Invalidate(K): 作废远程cache中包含地址K的数据块
    + Fetch(K): 从远程cache中取出包含地址K的数据块，并送到宿主节点。把远程cache中那个块的状态改为“共享”
    + Fetch&Inv(K): 从远程cache中取出包含地址K的数据块，并送到宿主节点。然后作废远程cache中的那个块。
  + 宿主节点发送给本地节点的消息
    + DReply(D): D表示数据内容。把从宿主存储器获得的数据返回给本地cache
  + 远程节点发送给宿主节点的消息
    + WtBack(K, D): 把远程cache中包含地址K的数据块写回到宿主节点中，该消息是远程节点对宿主节点发来的“取数据”或“取/作废”消息的响应。
  + 本地节点发送给被替换块的宿主节点的消息
    + MdSharer(P, K): 用于当本地cache中需要替换一个包含地址K的块、且该块未被修改过。这个消息发给该块宿主节点，请求它将P从共享集中删除。如果删除后共享集位空，则宿主节点还要将该块状态改为“未缓存”(U)
    + WtBack2(P, K, D): 用于当本地cache中需要替换一个包含地址K的块、且该块已经被修改过。这个消息发给该块宿主节点，完成两步：1. 写回该块；2. 进行与MdSharer相同操作

### 目录协议实例
+ 在基于目录的协议中，目录承担了一致性协议操作主要功能
  + 本地节点把请求发给宿主节点中的目录，再由目录控制器有选择的向远程节点发出相应小欧希
  + 发出的消息会产生两种不同类型动作
    + 更新目录状态
    + 使远程节点完成相应操作
+ 目录的状态转换及相应的操作
  + 目录中存储器块的状态有3种
    + 未缓存
    + 共享
    + 独占
  + 位向量记录拥有其副本的处理器集合。该集合称为共享集合
  + 对于从本地节点发来的请求，目录所进行的操作包括
    + 向远程节点发送消息以完成相应的操作。这些远程节点由共享集合指出
    + 修改目录中该块的状态
    + 更新共享集合
  + 目录可能收到3中不同的请求
    + 读不命中
    + 写不命中
    + 数据写回
  + 当一个块处于未缓存状态时，对该块发出的请求及处理操作为
    + RdMiss(读不命中): 将所要访问的存储器数据送往请求方处理机，且该处理机成为该块的唯一共享节点，本块的状态编程共享
    + WtMiss(写不命中): 将所要访问的存储器数据送往请求方处理机，该块的状态变成独占，表示该块仅存在唯一的副本。其共享集合仅包含该处理机，指出该处理机是其拥有者。
  + 当一个块处于共享状态时，其在处理器中的数据是当前最新的，对该块发出的请求及其处理操作为
    + RdMiss: 将存储器数据送往请求方处理机，并将其加入共享集合
    + WtMiss: 将数据送往请求方处理机，对共享集合中所有的处理机发送作废消息，且将共享集改为仅含有该处理机，该块的状态变为独占
  + 当一个块处于独占状态时，该块的最新值保存在共享集合所指出的唯一处理机（拥有者）中
    + RdMiss: 将“取数据”的消息发送往拥有者处理机，将它所返回给宿主节点的数据写入存储器，并进而把该数据送回请求方处理机，将请求方处理机加入共享集合。此时共享集合中仍保留拥有者处理机（因为它仍然拥有一个可读副本）。该块状态变为共享。
    + WtMiss: 该块将拥有一个新的拥有者。给旧的拥有者处理机发送消息，要求它将数据块送回宿主节点写入存储器，然后再从该节点送给请求方处理机。同时还要求旧拥有者处理机中把该块作废。把请求处理机加入共享者集合，使之成为新的拥有者。该块的状态仍然是独占。
    + WtBack: 当一个块的拥有者处理机要从其cache中把该块替换出去时，必须将该块写回其宿主节点的存储器中，从而使存储器中相应的块中存放的数据是最新的（宿主节点实际成为拥有者）。该块的状态变成未缓冲，其共享集合为空。

### 目录的三种结构
+ 不同目录协议的主要区别主要有两个
  + 所这是的存储器块的状态及其个数不同
  + 目录的结构
+ 目录协议分为3类
  + 全映像目录
  + 有限映像目录
  + 链式目录

## 同步
+ 互斥过程：典型的互斥是临界资源的串行使用
  + 特点：每个进程都需要经历测锁->上锁->开锁的过程，共有n次竞争上锁、n次开锁。主需1个锁变量
+ 同步过程：典型的同步操作是栅栏：栅栏强制所有先到达该栅栏的进程进行等待，直到最后一个进程到达，由它释放全部进程，继续执行
  + 特点：只需1次上锁、1次开锁，n-1个进程需要测锁等待。需要两个锁变量。
+ 锁的类型及其操作
  + 布尔锁
    + 状态：开放、锁闭
    + 操作：读锁、加锁、开锁
    + 用途：互斥，保证临界资源操作的唯一性
  + 算数锁
    + 状态：负（拒绝/欠缺数）、零（空闲）、正（累计数/富余数）
    + 操作：读锁、增值、减值、清零
    + 用途：同步，记录等待中的进程数，或已通过的进程数

### 多处理机的锁存储模型
多处理机系统都用多个局部cache满足各处理机并行访存的需要，但对进程控制用的信号灯（或锁）来说，多副本就破坏了它们的唯一性，造成同一变量再不同处理机看来有不同值的后果。因此信号灯（锁）的管理需要遵循以下原则
+ 读信号灯再当地cache进行，只要复件有效
+ 写信号灯必须直接作用于主存元件，采用“写穿”策略
+ 写过程有排它性，硬件推迟其它处理机的写请求
+ 写完元件要通知所有其它cache中的复件作废，即“一写多废”，让其它处理机随后发生“读失效”或“写失效”
+ 信号灯管理系统的时间开销主要来源于“读失效”和“写失效”，或称“总线事务处理”次数
+ 探讨不同的锁管理机制，目的是在程序正确前提下，减少时间开销

### 基本硬件原语
+ 在多处理机中实现同步，所需要的主要功能是：
  + 一组能以原子操作的方式读出并修改存储单元的硬件原语。它们都能以原子操作的方式读/修改存储单元，并指出所进行的操作是否以原子的方式进行。
  + 通常情况下，用户不直接使用基本的硬件原语，原语主要供系统程序员用来编制同步库函数。，

+ 典型操作：原子交换EXCH(automic exchange)
  + 功能：将一个存储单元的值和一个寄存器值进行交换。建立一个锁，锁值：
    + 0：表示开的（可用）
    + 1：表示已上锁（不可用）
  + 处理器上锁时，将对应于该锁的存储单元的值于存放在某寄存器中的的1进行交换。
    + 如果返回值为1，别的处理器已经上了锁
    + 如果返回值为0，存储单元的值此时已经置换为了1，防止了别的进程竞争该锁
  + 实现同步的关键：交换操作的原子性
+ 测试并置定(test_and_set)
  + 先测试一个存储单元的值，如果符合条件则修改其值
+ 读取并加1(fetch_and_increment)
  + 返回存储单元的值并自动增加该值
+ 使用指令对
  + LL(load linked 或 load locked)：读取“锁”单元原值到指定寄存器。注意该指令通常只访问cache
  + SC(store conditional)：一条特殊写指令，它首先再读“锁”单元，如果与LL所读值相同，则将指定寄存器中的新值送给“锁”单元，并返回只1表示成功，如果内容不同，直接返回0表示失败。
  + 指令顺序执行：
    + 如果由LL指明的存储单元的内容在SC对其进行写之前已被其它指令改写过，则第二条指令SC执行失败
    + 如果在两条指令件进行切换也会导致SC执行失败
  + SC将返回一个值来指出该指令操作是否成功
    + “1”：成功
    + “0”：不成功
  + LL返回该存储单元初始值

```asm
# implement fetch_and_increment
try:LL R2, 0(R1) # 把0(R1)中的值放入R2中
    ADD R2, R2, 1  
    SC R2, 0(R1) # 再次读取0(R1)，如果和LL读取时候的值相同，则把R2中的值放入0(R1)，R2置1；如果0(R1)的值变化，不动0(R1)的内容，R2置0。
    BEQZ R2, try
```

### 用一致性实现锁
+ 采用多处理机的一致性机制来实现自旋锁
+ 自旋锁：处理器环绕一个锁不停地请求获得该锁。适合：锁被占用的时间很少，再获得锁后加锁过程延迟很小
+ 无cache一致性机制：在存储器中保存锁变量，处理器可以不断地通过一个原子操作请求使用权。
  + e.g. 利用原子交换操作，并通过测试返回值二直到锁的使用情况。释放锁的时候，处理器只需简单地将锁置为0
+ 机器支持cache一致性
  + 将锁调入cache，并通过一致性机制使锁值保持一致
  + 优点：
    + 可使“环绕”的进程只对本地cache中的锁（副本）进行操作，而不用在每次请求占用锁时都进行一次全局的存储器访问
    + 可利用访问锁时所具有的局限性，即处理机最近使用过的锁不久又会使用（减少为获得锁而花费的时间）
  + 改进自旋锁（获得第一条优点，避免写操作）：只对本地cache中锁的副本进行读取和检测，直到发现该锁已经被释放。然后，该程序立即进行交换操作，去跟在其它处理器上的进程征用该锁变量。

### 同步性能问题
简单自旋锁不能很好地适应可扩缩性。大规模多处理机中，若所有的处理器都同时争用同一个锁，则会导致大量的争用和通信开销。

+ 自旋锁的不足
  + 由于自旋锁的无序竞争，可能造成等待时间演唱，并且存在“不公平”的问题
    + 随着处理器个数的不断增加，自旋锁竞争性操作增加了系统负担，从而导致更长的等待时间
    + 一个处理器释放自旋锁时要通知等待中的所有处理器，将cache副本作废，那么集合距离上临近它的处理器可能会较先的更新cache，因而增大了获得自旋锁的纪律
  + 由于每个申请自旋锁的处理器均在全局变量slock上忙等待，系统总线将因为处理器件的cache同步而导致繁重的流量（即因读失效或写失效引起的cache调入、调出），从而降低了系统整体的性能。


# 重要公式整理
## 第一章 计算机体系结构的基本概念
### amdahl公式
在一个系统中，Fe表示可改进部分占用的比例，Se表示可改进部分可提升的比例，则系统加速比
$$ S_n = \frac{1}{(1 - Fe) + \frac{Fe}{Se}}$$
当有多个比例的时候，可以使用公式$S_n = \frac{1}{(1-\sum _i f_i) + \sum _i \frac{f_i}{S_i}}$，但是更推荐画出比例图以后手动计算一下。
### CPU性能
$$ CPU时间 = \frac{总时钟周期数}{时钟频率} $$
指令时钟数CPI(Cycles Per Instruction) 
$$ CPI = 总时钟周期数 \div InstructionCount $$
因此，CPU时间也可以改写为$CPU时间=CPI \times IC \div 时钟频率$

## 第三章 流水线
### 流水线性能指标
#### 吞吐率
对于一个有k段的流水线，完成n个连续任务所需要的时间
$$ T_k = (k + n - 1) \Delta t $$
流水线的实际吞吐率
$$ TP = \frac{n}{(k + n - 1) \Delta t} $$
最大吞吐率
$$ TP_{max} = lim _{n->\inf} \frac{n}{(k+n-1)\Delta t} = \frac{1}{\Delta t} $$
各段时间不等的流水线的实际吞吐率为
$$TP = \frac{n}{\sum _{i=1}^k \Delta t_i + (n-1)max(\Delta t_1, \Delta t_2, ..., \Delta t_k)}$$
流水线的最大吞吐率$TP_{max} = \frac{1}{max(\Delta t_1, ..., \Delta t_k)}$
#### 流水线的加速比
流水线的加速比是不使用流水线时所用的时间除以使用流水线后所用的时间

每段时间相等的流水线，加速比为$S=\frac{nk}{k+n-1}$

每段时间不相等的流水线，加速比为$S=\frac{n \sum _{i=1}^k \Delta t_i}{\sum _{i=1}^k \Delta t_i + (n-1)max(\Delta t_1, ..., \Delta t_k)}$
#### 流水线的效率
流水线的效率是设备实际使用时间与整个运行时间的比值。从时空图的角度来看就是方框面积总和除以整个图的构成的矩形面积。

每段时间相同的流水线，效率也相同，$e_1=e_2=...=e_k=\frac{n \Delta t}{T_k} = \frac{n}{k + n - 1}$

整条流水线的效率$E = \frac{n}{k + n - 1}$，容易看出，流水线的效率与吞吐率成正比，$E=TP \times \Delta t$

## 第七章 存储器
### 缓存平均访问时间
基础公式
$$ 平均访存时间= 命中时间 + 不命中率 \times 不命中开销 $$
采用写分配时候，平均访问时间$$ T_A = HT_1 + (1-H) * (T_1 + T_2 + T_B) $$
其中，H为命中率，$T_1$为访问一级缓存的时间，$T_2$为访问二级缓存的时间，$T_B$为把数据从二级缓存调入一级缓存的时间。

当有两级cache的时候
$$ 平均访存时间 = 命中时间_{L1} + 不命中率_{L1} \times (命中时间_{L2} + 不命中率_{L2} \times 不命中开销_{L2}) $$
### 程序执行时间
考虑访存的时候，
$$ CPU时间=(CPU执行周期数 + 访存次数 \times 不命中率 \times 不命中开销) * 时钟周期时间 $$
$$ CPU时间 = IC \times (CPI_{execution} + 每条指令的平均访存次数 \times 不命中率 \times 不命中开销) \times 时钟周期时间 $$

### 降低cache不命中率
+ 增加cache块大小
+ 增加cache容量
+ 提高相联度
+ 伪相联cache
+ 硬件预取
+ 编译器控制的预取
+ 编译器优化
+ “牺牲”cache

### 减少cache不命中开销
+ 多级cache
+ 让读不命中优先于写
+ 写缓冲合并
+ 请求字处理技术
+ 非阻塞cache技术

## 第八章 输入输出系统
### 可靠性模型
对于一个串联系统，系统的可靠性$R_s$
$$ R_s = \prod _{i=1}^n R_i $$
对于并联系统，
$$ R_s = 1 - \prod _{i=1}^n (1- R_i) $$
串并联系统，其中n代表串联倍数，m代表并联倍数
$$ R(t) = 1-(1-R_i ^n (t))^m $$
并串联系统
$$ R(t) = (1-(1-R_i(t))^m)^n $$